0. Типы переменных	
Беззнаковые 8-битные целые числа 
uint8 	Беззнаковые 8-битные целые числа        от 0 до 255
uint16 	Беззнаковые 16-битные целые числа  	от 0 до 65535
uint32 	Беззнаковые 32-битные целые числа  	от 0 до 4294967295
uint64 	Беззнаковые 64-битные целые числа  	от 0 до 18446744073709551615
int8 	Знаковые 8-битные целые числа  	от -128 до 127
int16 	Знаковые 16-битные целые числа  	от -32768 до 32767
int32 	Знаковые 32-битные целые числа  	от -2147483648 до 2147483647
int64 	Знаковые 64-битные целые числа  	от -9223372036854775808 до 9223372036854775807

В дополнение к этому существуют два типа-псевдонима: byte (то же самое, что uint8) и rune (то же самое, что int32). Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип byte в Go часто используется для определения других типов.


Также существует 3 машинно-зависимых целочисленных типа: uint, int и uintptr. Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера:

    int: представляет целое число со знаком, которое в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.

    uint: представляет целое число только без знака, которое, аналогично типу int, в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.

В общем, если вы работаете с целыми числами — просто используйте тип int.


В Go есть два вещественных типа: float32 и float64 (соответственно часто называемые вещественными числами с одинарной и двойной точностью), а также два дополнительных типа для представления комплексных чисел (чисел с мнимой частью): complex64 и complex128. При работе с вещественными числами достаточно использовать float32, однако, если Вы хотите работать с более точными числами, можно использовать и float64. 

Булевый тип - bool (названный так в честь Джорджа Буля) — это специальный целочисленный тип, используемый для представления истинности и ложности. Переменная такого типа будет занимать только один байт. С этим типом используются три логических оператора:
Литерал 	Пояснение
&& 	И
|| 	ИЛИ
! 	НЕ
Переменная типа bool может принимать только два значения: truе или false



1. go build main.go -- Если же вы хотите скомпилировать программу, то-есть получить готовый бинарник для запуска на машинах без Go (для windows это будет .exe) - выполните следующую команду
2. go run main.go -- запуск. Это команда так же компилирует программу, но скомпилированныый файл запускается сразу, не сохранаясь его.



3. package main - объявили новый пакет, в любом проекте должен быть обязательно пакет main. Запуск программы начинается именно с этого пакета. Подробнее о пакетах мы поговорим в другом модуле.
4. import "fmt" - импортировали пакет ввода/вывода.



5. func main(){} - объявили функцию c названием "main". Имя main является особенным, эта функция будет вызываться сама при запуске программы. Эта функция тоже обязательная в программе, с неё начинает работать ваш код. 



6. fmt.Println("Hello, Go!")  - здесь мы выводим уже то, что нам нужно, используя встроенную функцию Println() из пакета fmt.



7. Для определения переменной применяется ключевое слово var, после которого идет имя переменной, а затем указывается ее тип: var имя_переменной тип_данных. Пример: var hello string или var a, b, c string. Важно учитывать, что Go - регистрозависимый язык, то есть переменные с именами hello и Hello будут представлять собой разные переменные. Еще примеры объявления переменных:
var x int
var y float64
var max, min int

Хороший пример:
package main
import "fmt"

func main() {
  var a, b, c int = 1, 2, 3
  fmt.Printf("%d %d %d\n", a, b, c)
  d, e := "AAAA", "BBBB"
  fmt.Print(d, e)
}
Выведет: 
1 2 3
AAAABBBB
 


8. Мы можем одновременно с объявлением переменной задать ей некоторое значение. Например:
var x int = 10
var c string = "Hello World!"
var z float64 = 1.045  



9. Также допустимо присваивать значение переменной в момент ее объявления следующим образом:
var a = 12
var hello = "Hello"
В этом случае компилятор сможет сам определить тип присваиваемого значения.



10. Компилятор определяет код буквы в unicode и присваивает его переменной symbol. То есть мы не храним никакую 'c', а храним лишь число 99. Функция string() из переданного в него числа 99 делает строку 'c'.
var symbol int32 = 'c'
fmt.Println(string(symbol))



12. Значения по умолчанию 
Когда объявляется переменная, она автоматически содержит значение по умолчанию для своего типа: 0 для int, 0.0 для float, false для bool, пустая строка для string, nil для указателя и т.д.



13. Теперь мы можем объявить переменную типа string или int, присвоить ей любое значение, а затем вывести.

package main

import "fmt"

func main() {

    var hello string

    hello = "Hello Go!"

    var a int = 2019

    fmt.Println(hello)
    fmt.Println(a)
}



14. Можно группировать переменные. 

var (
    x int = 10
    c string = "Hello World!"
    z float64 = 1.045
)

А еще в Unicode можно записать так

var symbol int32 = '\u7777'
var symbol1 uint64 = '\u5555'// так тоже прокатит, памяти только больше сожрет
// Будет какая нибудь ерунда типа иероглифа, можно проверить)
fmt.Println(string(symbol) + " " + string(symbol1))



15. Также существует более краткий способ объявить переменную (краткое объявление доступно только внутри функций, но о них мы поговорим во 2 модуле):
a := 5
Это то же самое, что:
var a int = 5



16. Стоит отметить, что краткое объявление доступно только внутри функций. Вне той же main() компилятор вам не даст использовать объявление данного типа и примет только var someInt int = 0. (Вне функций каждый оператор должен начинаться с ключевого слова (var, func), в связи с этим кратко объявить переменную нельзя)



17. Также можно объявить сразу несколько переменных в одном блоке var:
package main

import "fmt"
 
func main() {
    var (
        name string = "Dima"
        age int = 23
    )
     
    fmt.Println(name)
    fmt.Println(age)
}



18. При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:

var m int = 10 / 6
------------------
Вывод: 1



19. Чтобы получить в результате деления вещественное число,  как минимум один из операндов также должен представлять собой вещественное число и результат мы должны при этом тоже сохранять в переменную вещественного типа:

var m float32 = 10.0 / 6
----------------------
Вывод: 1.6666666



20. % Возвращает остаток от деления (в этой операции могут принимать участие только целые числа)﻿:

var c int = 10 % 3
---------------
Вывод: 1

a := 100.


Любопытный пример:
package main

import "fmt"

func main(){
    var x, p, y, count int
    fmt.Scan(&x, &p, &y)
    
    for x <= y {
	x = x * ((100.0 + p)/100.0) -- он тупа понизит тип 100.0 до int, обрежет дроби в вычислении и сделает бесконечный цикл
	//x = x * ((100.1 + p)/100.0) -- он выведет ошибку связанную с типами.
        //x = x * (100 + p)/100 -- нормально посчитает, но в конце тупо обрежет дроби
	fmt.Println(x)
        count++
    }
    
    fmt.Println(count)
}

Еще один классный пример:

package main

import (
  "fmt"
  "reflect"
)

func main() {
  a := 0
  fmt.Println(reflect.TypeOf(a))
  x := 100.0 + a
  fmt.Println(reflect.TypeOf(x))
}
ВЫВЕДЕТ: int 
	 int

package main

import (
  "fmt"
  "reflect"
)

func main() {
  a := 0
  fmt.Println(reflect.TypeOf(a))
  x := 100.0 + 10
  fmt.Println(reflect.TypeOf(x))
}
ВЫВЕДЕТ: int 
	 float


21. Чтение данных с консоли:
fmt.Scan(&a), где &a - ссылка (более точно - адрес) на переменную a. Если проще, то введённое число запишется из консоли прямиком в эту переменную и там будет храниться
Теперь давайте прочтём, например, имя и возраст:

package main

import "fmt"
 
func main() {
    var name string
    var age int
    fmt.Print("Введите имя: ")
    fmt.Scan(&name) 
    fmt.Print("Введите возраст: ")
    fmt.Scan(&age)
     
    fmt.Println(name, age)
}


Также можно читать с консоли сразу несколько переменных:
fmt.Scan(&a, &b, &c)



22. Для вывода данных на консоль мы на данном этапе будем пользоваться двумя методами, которые присутствуют в пакете fmt. Это Print() и Println().
Первый метод при выводе нескольких объектов вставляет между ними пробелы, если среди них нет строк.
Второй всегда ставит пробелы между выводимыми объектами, плюс добавляет новую строку. То есть он пригодится, если нам необходимо будет сделать вывод на нескольких строках.
Например:
fmt.Print("hello, world")
fmt.Print("hello, world")
// вывод будет в одну строку:
// hello, worldhello, world
Но если мы сделаем вот так:
fmt.Println("hello, world")
fmt.Print("hello, world")
// вывод будет в две строки:
// hello, world
// hello, world
Теперь как выводятся несколько объектов:
fmt.Print("Ivan", 27) // Ivan27
fmt.Println("Ivan", 27) // Ivan 27
fmt.Print(33, 27) // 33 27

Еще пример вывода, используя строки и переменные:
package main

import "fmt"

func main() {
    name := "Ivan"
    age := 27
    fmt.Println("My name is", name, "and I am", age, "years old.")
}

// вывод:
// My name is Ivan and I am 27 years old.



23. В Go есть конструкции вывода, аналогичные C:

package main

import "fmt"

const (
	DegInHour = 30
	MinInDeg  = 2
	TimeFormat = "It is %d hours %d minutes."
)

func main() {
	var input int32
	fmt.Scan(&input)

	hours := input / DegInHour
	minutes := (input % DegInHour) * MinInDeg

	fmt.Printf(TimeFormat, hours, minutes)
}



24. Однострочный комментарий располагается в одну строку после двойного слеша (//). Все, что идет после этих символов, воспринимается компилятором как комментарий. Многострочный комментарий заключается между символами /* и */ и может занимать несколько строк



25.Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. 

Для определения констант применяется ключевое слово const:
const pi float64 = 3.1415

Мы не можем менять значение константы:
const pi float64 = 3.1415
pi = 2.7182             // ! Ошибка

Константы, как и обычные переменные, можно объявлять в блоке:

const (
	a int = 45
	b float32 = 3.3
)

 Также можно не указывать значение следующей константы по порядку (значение будет скопировано):

package main

import (
	"fmt"
)

const(
	A int = 45
	B
	C float32 = 3.3
	D
)
func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}



26. iota идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.

const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2


const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8


const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0

Более подробный пример:
const (
	a = iota + 1         /* здесь задали правило, по которому должно вычисляться значение
	                        потенциальной константы, сама iota здесь равна нулю */
        _                    /* здесь значение потенциальной константы уже 2 ,
                            поскольку iota выдаёт 1, но правило из первой константы
                            гласит, что iota + 1 ; а теперь, поскольку имя константы здесь
                            указано _ (по сути идентификатор-заглушка), то пропускаем */ 
	b                    /* генератор констант iota выдаёт 2, но помним правило iota + 1,
                            поэтому b получит значение 3 */
	c                    // c получит значение 4
	d = c + 2            /* генератор констант iota выдаёт 4, но помним правило iota + 1,
                            поэтому значение потенциальной константы должно быть 5,
                            но в константу d кладётся c + 2 , равное 6  */
	t                     /* генератор констант iota выдаёт 5, но помним правило iota + 1,
                            поэтому значение константы t 6 */
	i                    // аналогично, i получает значение 7
	i2 = iota + 2        /* генератор констант iota выдаёт 7, далее делаем iota + 2,
                            в итоге значение константы i2 стаёт 9 */
)

написал эту простыню не с целью подсказку выкатить, а подробно разжевать.

iota по сути просто генератор, который начинает генерить с 0 с шагом , равным 1, причём в каждом следующем блоке const он сбрасывается на 0. 

Ещё важно сказать, что как только мы напишем в какой-нибудь строке выражение с iota (в данном случае мы написали i2 = iota + 2), так сразу предыдущее правило с  iota отменяется, а в силу вступает новое, то есть



27. Условные выражения представляют операции отношения и логические операции. Они представляют некоторое условие и возвращают значение типа bool: true (если условие истинно) или false (если условие ложно).
package main
import "fmt"
 
func main() {
    var a int = 8
    var b int = 3
    var c bool = a == b
    fmt.Println(c)      // false
}



28.  Условная конструкция if

if a < b {     
      fmt.Println("a меньше, чем b")  
  }


Так же как и for (про него в следующем уроке), оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные, объявленные в этом блоке, доступны только в области видимости, которая существует до конца if. Пример:

if v := math.Pow(x, n); v < lim {
   // ...
}



29. Условные конструкции else if и else 

if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}


Пример использования:
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	a := n / 100
	b := n / 10 % 10
	c := n % 10
	if a == b || b == c || a == c {
		fmt.Println("NO")
	} else {
		fmt.Println("YES")
	}
}

И еще один пример:

package main

import "fmt"

func main(){
    var a int
    fmt.Scan(&a)
    
    if a / 100 == a / 10 % 10 || a / 100 == a % 10 || a / 10 % 10  == a % 10 { 
        fmt.Println("NO")
    } else { 
         fmt.Println("YES") 
    }
}


30. оператор switch (переключатель)
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с выражением. Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает else в операторе if).
В switch можно использовать любой тип данных.

Стоит дополнить, что:

1) В Go код после case выполняется до следующего case, и нет нужды каждый case-блок заканчивать ключевым словом break (данная особенность добавлена в язык специально, чтобы уменьшить количество ошибок в switch-блоках). Если в текущем case написать fallthrough, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего case) условие:

v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default

2) Существует специальная форма switch, допускающая использование произвольных условий в каждом case-блоке:

var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}

То есть, сразу после switch "переключатель" не нужен, а после каждого case идет выражение с произвольным условием.

Возможно поместить несколько выражений в одном кейсе.
package main
 
import (
    "time"
    "fmt"
)
 
func main() {
 
    switch time.Now().Weekday() {
        
    case time.Monday, time.Tuesday, time.Wednesday, time.Thursday, time.Friday:
        fmt.Println("будний день")
    case time.Saturday, time.Sunday:
        fmt.Println("выходные дни")
    }
}

Вот еще интересный пример использования switch:
package main 

import "fmt"

func Foo(n int) int {
    fmt.Println(n)
    return n
}

func main() {
    switch Foo(3) {
    case Foo(1), Foo(2), Foo(3), Foo(4):
        fmt.Println("First case")
        fallthrough
    case Foo(5):
        fmt.Println("Second case")
    }
}

Output:

3
1
2
3 
First case
Second case

Необязательный оператор инициализатор может предшествовать выражению switch. Инициализатор и выражение разделяются точкой с запятой.
package main
 
import (
    "fmt"
)
 
func main() {
 
    switch num := 6; num % 2 == 0 {
 
    case true:
        fmt.Println("even value")
 
    case false:
        fmt.Println("odd value")
    }
}

В данном примере есть switch инициализатор и выражение. Оператор switch определяет, если значение четное или нечетное.
Go
switch num := 6; num % 2 == 0 {

num := 6 является switch инициализатором, а num % 2 switch выражением.

31.Единственной конструкцией для циклов в Go является оператор for.
Его базовая форма выглядит следующим образом:

for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}

Пример использования:
package main

import "fmt"

func main() {
	sum := 0
	for i := 1; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}


Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне:

var i = 1
for ; i < 10; i++{
    fmt.Println(i * i)
}

Можно убрать изменение счетчика в само тело цикла и оставить только условие:

var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}

Если цикл использует только условие, то его можно сократить следующим образом:

var i = 1
for i < 10{
    fmt.Println(i * i)
    i++
}

При этом в последнем случае мы получим по сути аналог цикла while в других языках программирования.

Так же можно реализовать бесконечный цикл:

for {

}

Кстати, иногда удобно пользоваться такой конструкцией ввода данных:
(но будьте осторожны, ведь мы не обрабатываем здесь ошибки)

var n int
// считываем числа пока не будет введен 0
for fmt.Scan(&n); n != 0; fmt.Scan(&n){
	fmt.Println(n)
}



32. Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации. В этом случае можно использовать оператор continue. Например, нам нужно в диапазоне от 1 до 10 посчитать сумму нечетных чисел. Если нам встретится четное число, мы можем просто перейти к следующей итерации с помощью continue:

var sum = 0
 
for i := 1; i <= 10; i++{
    if i % 2 == 0 {
        continue        // переходим к следующей итерации
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 25

Оператор break полностью осуществляет выход из цикла:

var sum = 0
 
for i := 1; i <= 9; i++{
    if i > 4 {
        break       // если число больше 4 выходим из цикла
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 10



33. fmt.Printf() на вход принимает сначала строку форматирования, а только потом переменные для вывода. Строка форматирования представляет набор спецификаторов. Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента %.  В качестве примера возьмем глагол - спецификатор %q , с помощью него можно вывести символ в кавычках:

var a rune = 'Ы'
fmt.Printf("%q", a)
// вывод: 'Ы'

Каждый спецификатор представляет определенный тип данных:

    %t: для вывода значений типа boolean (true или false)

    %b: для вывода целых чисел в двоичной системе

    %c: для вывода символов, представленных числовым кодом

    %d: для вывода целых чисел в десятичной системе

    %o: для вывода целых чисел в восьмеричной системе

    %q: для вывода символов в одинарных кавычках

    %x: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f

    %X: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F

    %U: для вывода символов в формате кодов Unicode, например, U+1234

    %e: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78

    %E: тоже самое что %e но в верхнем регистре, например, -1.234456E+78

    %f: для вывода чисел с плавающей точкой, например, 123.456

    %F: то же самое, что и %f

    %g   %e для огромных экспонент, %f в противном случае

    %G    %E для огромных экспонент, %F в противном случае

    %s: для вывода строки

    %p: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)

    %T для вывода типа переменной

Также можно применять универсальный спецификатор %v, который для типа boolean аналогичен %t, для целочисленных типов - %d, для чисел с плавающей точкой - %g, для строк - %s.

К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, %9f - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: %.2f - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

    %f: точность и ширина значения по умолчанию

    %9f: ширина - 9 символов и точность по умолчанию
    (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)

    %.2f: ширина по умолчанию и точность - 2 символа

    %9.2f: ширина - 9 и точность - 2

    %9.f: ширина - 9 и точность - 0

Также из флагов следует отметить дефис -, который дополняет значение пробелами не слева, как по умолчанию, а справа.

Примеры:

var a float64 = 100.123456
fmt.Printf("это число %f типа %T", a, a)
// вывод: это число 100.123456 типа float64

var a1 byte = 's'
var a2 int = 1234
fmt.Printf("%q %b", a1, a2)
// вывод: 's' 10011010010


// использование \n позволяет сделать перенос строки
var a1 string = "123"
var a2 string = "1234"
fmt.Printf("%q \n%s", a1, a2)
// вывод: 
// "123" 
// 1234

Примеры форматирования чисел с плавающей запятой(включая с дефисом):
var a = 3.14
fmt.Printf("|%8f|\n", a)
fmt.Printf("|%8.1f|\n", a)
fmt.Printf("|%8.3f|\n", a)
fmt.Printf("|%-8.3f|\n", a)

вывод:
|3.140000|
|     3.1|
|   3.140|
|3.140   |



34. Также есть функция Sprintf() которая работает как и Printf(), за исключением того что она ничего не печатает, а возвращает результат форматирования, рассмотрим пример:

package main

import (
	"fmt"
)

func main() {
	var a float64 = 100.123456789
	result := fmt.Sprintf("%.2f", a)
	fmt.Printf("%q", result) // вывод: "100.12"
        // result будет типа string
}



35. Литералы строк
Вначале определим разницу между литералами строк и значениями строк. Литерал строк — это то, что мы видим в исходном коде компьютерной программы, включая кавычки. Значение строки — это то, что мы видим в окне терминала когда вызываем функцию fmt.Println после запуска программы Go.
В простой программе Hello, World! литерал строки будет выглядеть как "Hello, World!", а значением строки будет Hello, World! без кавычек.

Кавычки и обратный апостроф
В Go можно использовать обратный апостроф (`) или двойные кавычки ("), поэтому мы можем легко вставлять цитаты в строку, выделяя их двойными кавычками, в то время как сама строка выделена обратными апострофами:
`Sammy says, "Hello!"`

Также вы можете использовать обратные апострофы и заключить строку в двойные кавычки:
"Sammy likes the `fmt` package for formatting strings.."

Кроме того, комбинирование обратных апострофов и двойных кавычек позволяет контролировать отображение символов кавычек и одинарных кавычек в строках.
Важно помнить, что при использовании обратных апострофов в Go создается чистый литерал строки, а при использовании двойных кавычек — интерпретированный литерал строки. 

Использование обратных кавычек, как в ` ```bar``` `, создаст необработанный строковый литерал. В необработанном строковом литерале между кавычками может появиться любой символ, за исключением обратных кавычек.Обратная косая черта не имеет особого значения внутри необработанных строковых литералов. Например, \n будут отображаться как настоящие символы, обратная косая черта \ и письмо n. В отличие от интерпретируемых строковых литералов, в которых \n вставил бы настоящую новую строку. 

Интерпретируемые строковые литералы представляют собой последовательности символов, заключенные в двойные кавычки, как в "bar". Внутри кавычек может быть любой символ, за исключением перевода строки и неэкранированных двойных кавычек.
Вы почти всегда будете использовать интерпретируемые строковые литералы, потому что они допускают использование в них экранирующих символов. 



36.Кавычки и обратный апостроф
https://stepik.org/lesson/351787/step/5?unit=335741



37. Многострочная печать

Многострочная печать строк делает текст более удобным для чтения. Размещение строк в нескольких рядах делает текст более понятным и упорядоченным, позволяет форматировать его как письмо или сохранить разрывы строк в стихотворении или тексте песни.

Для создания строк, отображаемых на нескольких рядах, их нужно заключить в обратные апострофы. Помните, что хотя при этом сохраняются символы возврата строки, создаваться будут чистые литералы строки.

`
This string is on
multiple lines
within three single
quotes on either side.
`

Если вы распечатаете этот текст, вы увидите, что символ возврата имеется в начале и в конце строки:

Output

This string is on
multiple lines
within three single
quotes on either side.

Если вам нужно создать интерпретированный литерал строки, вы можете использовать двойные кавычки и оператор +, но при этом вам нужно будет самостоятельно вставлять символы разрыва строки между рядами.

"This string is on\n" +
"multiple lines\n" +
"within three single\n" +
"quotes on either side."

Хотя с обратными апострофами намного проще распечатывать и читать длинный текст, если вам требуется интерпретированный литерал строки, вам нужно использовать двойные кавычки.



38.Чистые литералы строк
Что, если нам не нужно особое форматирование строк? Например, нам может понадобиться сравнить или оценить несколько строк программного кода, где целенаправленно используется символ обратного слеша, так что мы не хотим, чтобы Go использовал этот символ как управляющий или как элемент экранирования.

Чистый литерал строки указывает Go игнорировать все форматирование строки, включая управляющие символы.

Мы можем создать чистую строку, заключив строку в обратные апострофы:

fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)

Output

Sammy says,\"The balloon\'s color is red.\"

Построение чистой строки с помощью обратных апострофов вокруг нее позволяет сохранить в тексте символы обратного слеша и другие символы, которые используются в качестве управляющих символов.



!!!!39. Массивы!!!!
Массив — это последовательность элементов одного типа фиксированной длины. Объявление массива осуществляется следующим образом:

var a [3]int
fmt.Println(a) // [0 0 0]

При объявлении массива в квадратных скобках указывается его длина (length), которая совместно с типом элементов, определяет тип самого массива, т.е. [3]int не может просто так взаимодействовать с [5]int (массивы разной длины относятся к разным типам независимо от того, что хранят значения одного типа), также как не могут без приведения взаимодействовать int64 и int32.

Как мы увидели в приведенном примере, объявленный массив был при объявлении инициализирован нулевыми значениями (0 для int). Такое поведение не является стандартным, в частности в языках C / C++ объявленный массив нулевыми значениями не заполняется.

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):

var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]

Вместо явного указания длины массива мы можем указать символ многоточия (...) в квадратных скобках, тогда длина массива будет определена Go в зависимости от количества указанных при инициализации значений. Несмотря на то, что такой вариант допустим, он не считается идиоматичным для Go и не рекомендуется к использованию в документации.

Четвертый же способ инициализации позволяет явно указать значение, которое должно быть присвоено элементу массива с определенным индексом. В этом случае индексы могут появляться в любом порядке, а некоторые из них могут быть опущены; как и прежде, неуказанные значения получают нулевое значение типа элемента.



40. Сравнение массивов

Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false

Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).



41. Обращение к элементам массива. Индексы

Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация элементов массива начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:

package main

import "fmt"

func main() {   
    var numbers [5]int = [5]int{1,2,3,4,5}    

    fmt.Println(numbers[0])     // 1  
    fmt.Println(numbers[4])     // 5   

    numbers[0] = 87   

    fmt.Println(numbers[0])     // 87
}

Однако в большинстве случаев нам необходимо обратиться ко всем элементам массива и выполнить с ними определенную работу. Мы можем сделать это с помощью цикла:

a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
	// 1
	// 2
	// 3
	// 4
	// 5
}

Обратите внимание, что определяя условие продолжения выполнения цикла мы использовали встроенную функцию len(), возвращающую длину массива. Поскольку индексация элементов массива начинается с 0, то последний элемент массива a будет иметь индекс len(a) - 1.

При итерации по массиву мы можем использовать ключевое слово range, тогда цикл будет иметь следующий вид:

a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}

Range возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента. Любой из этих объектов должен быть опущен, если мы не планируем использовать его, для этого вместо имени переменной мы можем указать символ _. Кроме того, если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение:

a := [5]int{1, 2, 3, 4, 5}

for idx := range a {
    fmt.Println(a[idx])
}

for idx, _ := range a {
    // В этом случае следует использовать приведенный выше вариант,
    // хотя технически эти варианты работают одинаково
    fmt.Println(a[idx])
}

for _, elem := range a {
    fmt.Println(elem)
}

Необходимо запомнить, что в качестве второго значения range возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив. В этом случае мы должны обращаться к элементам массива по индексу:

a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]

Стоит отметить так же, что, если вам вдруг понадобится пройтись по длине массива или среза, но не понадобится ни элемент массива, ни индекс, то можно воспользоваться конструкцией:
for range array {
//paste some code here
}



42. Срезы и их связь с массивами:
Массив в Go представляет собой структуру данных, состоящую из упорядоченной последовательности элементов, емкость которой определяется в момент создания. После определения размера массива его нельзя изменить. Срез — это версия массива с переменной длиной, дающая разработчикам дополнительную гибкость использования этих структур данных. Срезы — это то, что обычно называют динамическими массивами в других языках.



43. Мы можем объединять элементы строк массива или среза с другими строками, используя оператор +:
fmt.Println("Sammy loves " + coral[0])
Output
Sammy loves blue coral

Если вы создадите массив целых чисел с большим количеством элементов, вы можете использовать функцию len() и в этом случае:

numbers := [13]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
fmt.Println(len(numbers)) // выведет: 13



44. Добавление элементов с помощью append()
append() — это встроенный метод Go для добавления элементов в тип данных коллекции. Но данный метод не будет работать с помощью массива. Как уже отмечалось, основное отличие массивов от срезов заключается в том, что размер массива нельзя изменить. Это означает, что хотя вы можете изменять значения элементов в массиве, вы не можете сделать массив больше или меньше после его определения.

Рассмотрим наш массив coral:
coral := [4]string{"blue coral", "foliose coral", "pillar coral", "elkhorn coral"}

Допустим, вы хотите добавить в массив элемент "black coral". Если вы попробуете использовать функцию append() в массиве с помощью следующей команды:
coral = append(coral, "black coral")

В результате вы получите сообщение об !ошибке!:
Output
first argument to append must be slice; have [4]string




!!!!45. Срезы!!!!
Срезы определяются посредством декларирования типа данных, перед которым идут пустые квадратные скобки ([]) и список элементов в фигурных скобках ({}). Вы видите, что в отличие от массивов, для которых требуется поставить в скобки значения int для декларирования определенной длины, в срезе скобки пустые, что означает переменную длину.

Создадим срез, содержащий элементы строкового типа данных:

seaCreatures := []string{"shark", "cuttlefish", "squid", "mantis shrimp", "anemone"}

При выводе среза мы видим содержащиеся в срезе элементы:

fmt.Printf("%q\n", seaCreatures)

Результат будет выглядеть следующим образом:
Output
["shark" "cuttlefish" "squid" "mantis shrimp" "anemone"]

Если вы хотите создать срез определенной длины без заполнения элементов коллекции, вы можете использовать встроенную функцию make():

oceans := make([]string, 3)

При печати этого среза вы получите следующий результат:
Output
["" "" ""]

Если вы хотите заранее выделить определенный объем памяти, вы можете использовать в команде make() третий аргумент:
oceans := make([]string, 3, 5)

При этом будет создан обнуленный срез с длиной 3 и заранее выделенной емкостью в 5 элементов.

Теперь вы знаете, как декларировать срез. Однако это не решает проблему с массивом coral, которая возникала у нас ранее. Чтобы использовать функцию append() с coral, нужно вначале научиться преобразовывать разделы массива в срезы.



45. Разделение массивов на срезы

Естьизначальный массив: coral := [4]string{"blue coral", "foliose coral", "pillar coral", "elkhorn coral"}

Используя числовые индексы для определения начальных и конечных точек, вы можете вызывать подразделы значений внутри массива. Эта операция называется разделением массива на слайсы, и вы можете сделать это посредством создания диапазона числовых индексов, разделенных двоеточием, в форме:[first_index:second_index]. Важно отметить, что при разделении массива на срезы в результате получается срез, а не массив.

Допустим, вы хотите вывести средние элементы массива coral, не включая первый и последний элемент. Для этого вы можете создать срез, начинающийся с индекса 1 и заканчивающийся перед индексом 3:

fmt.Println(coral[1:3])

Запуск программы с этой строкой даст следующий результат:
Output
[foliose coral pillar coral]

При создании среза (например, [1:3]), первое число означает начало среза (включительно), а второе число — это сумма первого числа и общего количества элементов, которое вы хотите получить:
array[starting_index : (starting_index + length_of_slice)]

В этом случае вы вызываете второй элемент (или индекс 1) в качестве начальной точки, а всего вызываете два элемента. Результат будет выглядеть следующим образом:
array[1 : (1 + 2)]

Вот как это было получено:
coral[1:3]

Если вы хотите задать начало или конец массива в качестве начальной или конечной точки среза, вы можете пропустить одно из чисел в синтаксисе array[first_index:second_index]. Например, если вы хотите вывести первые три элемента массива coral, а именно "blue coral", "foliose coral" и "pillar coral", вы можете использовать следующий синтаксис:

fmt.Println(coral[:3])

В результате будет выведено следующее:
Output
[blue coral foliose coral pillar coral]

Команда распечатала начало массива, остановившись непосредственно перед индексом 3.

Чтобы включить все элементы до конца массива, нужно использовать обратный синтаксис:

fmt.Println(coral[1:])

Получившийся срез будет выглядеть следующим образом:
Output
[foliose coral pillar coral elkhorn coral]



46. Преобразование массива в срез

Если вы создали массив и считаете, что для него требуется переменная длина, вы можете преобразовать этот массив в срез. Чтобы преобразовать массив в срез, используйте процесс разделения на срезы, описанный в разделе Разделение массивов на срезы настоящего документа, но пропустите указание обоих числовых индексов, определяющих конечные точки:
coralSlice := coral[:]

Учтите, что вы не сможете конвертировать саму переменную coral в срез, поскольку после определения переменной в Go ее тип нельзя изменить. Чтобы обойти эту проблему, вы можете скопировать полное содержание массива в новую переменную в качестве среза.

Если вы выводите coralSlice, результат будет выглядеть следующим образом:
Output
[blue coral foliose coral pillar coral elkhorn coral]

Теперь попробуйте добавить элемент black coral как в разделе массива, используя функцию append() в новом конвертированном срезе:

coralSlice = append(coralSlice, "black coral")
fmt.Printf("%q\n", coralSlice)

В результате будет выведен срез с добавленным элементом:
Output
["blue coral" "foliose coral" "pillar coral" "elkhorn coral" "black coral"]

В одном выражении append() можно добавить несколько элементов:

coralSlice = append(coralSlice, "antipathes", "leptopsammia")
Выведет:
["blue coral" "foliose coral" "pillar coral" "elkhorn coral" "black coral" "antipathes" "leptopsammia"]

Чтобы объединить два среза также можно использовать выражение append(), но при этом необходимо раскрыть аргумент второго элемента, используя синтаксис расширения ...:

moreCoral := []string{"massive coral", "soft coral"}
coralSlice = append(coralSlice, moreCoral...)
Выведет:
["blue coral" "foliose coral" "pillar coral" "elkhorn coral" "black coral" "antipathes" "leptopsammia" "massive coral" "soft coral"]



47. Удаление элемента из среза

В отличие от других языков, в Go отсутствуют встроенные функции для удаления элементов из среза. Для удаления элементов из среза их нужно вырезать.
Чтобы удалить элемент, нужно выделить в срез элементы до него, затем элементы после него, а затем объединить два новых среза в один срез, не содержащий удаленного элемента.

Если i — индекс удаляемого элемента, формат этого процесса будет выглядеть следующим образом:
slice = append(slice[:i], slice[i+1:]...)

Удалим из среза coralSlice элемент "elkhorn coral". Этот элемент располагается на позиции индекса 3.
coralSlice := []string{"blue coral", "foliose coral", "pillar coral", "elkhorn coral", "black coral", "antipathes", "leptopsammia", "massive coral", "soft coral"}
coralSlice = append(coralSlice[:3], coralSlice[4:]...)
fmt.Printf("%q\n", coralSlice)

Output
["blue coral" "foliose coral" "pillar coral" "black coral" "antipathes" "leptopsammia" "massive coral" "soft coral"]

Теперь элемент на позиции индекса 3, строка "elkhorn coral", больше не находится в срезе coralSlice.

Такой же подход можно применить и для удаления диапазона элементов. Допустим, мы хотим удалить не только элемент "elkhorn coral", но и элементы "black coral" и "antipathes". Для этого мы можем использовать в выражении диапазон:

coralSlice := []string{"blue coral", "foliose coral", "pillar coral", "elkhorn coral", "black coral", "antipathes", "leptopsammia", "massive coral", "soft coral"}
coralSlice = append(coralSlice[:3], coralSlice[6:]...)
fmt.Printf("%q\n", coralSlice)
Этот код убирает из среза индексы 3, 4 и 5:
Output
["blue coral" "foliose coral" "pillar coral" "leptopsammia" "massive coral" "soft coral"]



48. Измерение емкости среза с помощью cap()
Поскольку срезы имеют переменную длину, для определения размера этого типа данных метод len() подходит не очень хорошо. Вместо него лучше использовать функцию cap() для определения емкости слайса. Данная функция показывает, сколько элементов может содержать срез. Емкость определяется объемом памяти, который уже выделен для этого среза.

Функция len() возвращает длину фрагмента, т.е. количество элементов, хранящихся в нем в данный момент. Например, len(mySlice) возвращает количество элементов в срезе mySlice.

Функция cap() возвращает емкость среза, то есть максимальное количество элементов, которое может вместить базовый массив. Например, cap(mySlice) вернет максимальное количество элементов, которое может храниться в срезе mySlice.

Важно отметить, что при добавлении нового элемента в срез, если длина среза равна емкости среза, создается новый базовый массив с удвоенной емкостью, а исходные элементы копируются в новый массив. Это может привести к значительным накладным расходам, если срез постоянно расширяется сверх его емкости.

Примечание: поскольку длина и емкость массива всегда совпадают, функция cap() не работает с массивами.

Функция cap() обычно используется для создания среза с заданным числом элементов и заполнения этих элементов с помощью программных методов. Это позволяет предотвратить выделение лишнего объема памяти при использовании команды append() для добавления элементов сверх выделенной емкости.

Допустим, мы хотим составить список чисел от 0 до 3. Мы можем использовать для этого функцию append() в цикле или мы можем заранее выделить срез и использовать функцию cap() в цикле для заполнения значений.

Вначале рассмотрим использование append():

numbers := []int{}
for i := 0; i < 4; i++ {
	numbers = append(numbers, i)
}
fmt.Println(numbers)

Output
[0 1 2 3]

В этом примере мы создали срез, а затем создали цикл for с четырьмя итерациями. Каждая итерация добавляла текущее значение переменной цикла i к индексу среза numbers. Однако это могло повлечь выделение ненужного объема памяти, что могло бы замедлить реализацию программы. При добавлении к пустому срезу при каждом вызове функции append программа проверяет емкость среза. Если при добавлении элемента емкость среза превышает это значение, программа выделяет дополнительную память с учетом этого. При этом возникают дополнительные издержки программы, которые могут замедлить выполнение.

Теперь заполним срез без использования append() посредством выделения определенной длины / емкости:

numbers := make([]int, 4)
for i := 0; i < cap(numbers); i++ {
	numbers[i] = i
}

fmt.Println(numbers)

Output
[0 1 2 3]

В этом примере мы использовали make() для создания среза и предварительно выделили 4 элемента. Затем мы использовали функцию cap() в цикле для итерации по всем обнуленным элементам, заполняя каждый до достижения выделенной емкости. В каждом цикле мы поместили текущее значение переменной цикла i в индекс среза numbers.

Хотя с функциональной точки зрения использование append() и cap() эквивалентно, в примере с cap() не выделяется лишняя память, которая потребовалась бы при использовании функции append().



49. Построение многомерных срезов

Также вы можете определять срезы, содержащие в качестве элементов другие срезы, при этом каждый список в скобках содержится также в скобках родительского среза. Такие наборы срезов называются многомерными срезами. Их можно представить как описание многомерных координат. Например, набор из пяти срезов, каждый из которых содержит шесть элементов, можно представить как двухмерную сетку с длиной пять и высотой шесть.

Рассмотрим следующий многомерный срез:

seaNames := [][]string{{"shark", "octopus", "squid", "mantis shrimp"}, {"Sammy", "Jesse", "Drew", "Jamie"}}

Чтобы получить доступ к элементу этого среза, нам нужно использовать несколько индексов, каждый из которых соответствует одному измерению конструкции:

fmt.Println(seaNames[1][0])
fmt.Println(seaNames[0][0])

В приведенном выше коде мы вначале определяем элемент с индексом 0 среза с индексом 1, а затем указываем элемент с индексом 0 среза с индексом 0. Результат будет выглядеть так:

Output
Sammy
shark

Далее идут значения индекса для остальных отдельных элементов:

seaNames[0][0] = "shark"
seaNames[0][1] = "octopus"
seaNames[0][2] = "squid"
seaNames[0][3] = "mantis shrimp"

seaNames[1][0] = "Sammy"
seaNames[1][1] = "Jesse"
seaNames[1][2] = "Drew"
seaNames[1][3] = "Jamie"

При работе с многомерными срезами важно помнить, что для доступа к конкретным элементам вложенного среза нужно ссылаться на несколько числовых индексов.


 
50. Еще раз про срезы кратко:

Срезы (slice) представляют последовательность элементов одного типа переменной длины. В отличие от массивов длина в срезах не иксирована и динамически может меняться, то есть можно добавлять новые элементы или удалять уже существующие.

Срез определяется также, как и массив, за тем исключением, что у него не указывается длина:
1
	
var users []string

Также срез можно инициализировать значениями:
1
2
3
	
var users = []string{"Tom", "Alice", "Kate"}
// или так
users2 := []string{"Tom", "Alice", "Kate"}

К элементам среза обращение происходит также, как и к элементам массива - по индексу и также мы можем перебирать все элементы с помощью цикла for:
1
2
3
4
5
6
	
var users []string = []string{"Tom", "Alice", "Kate"}
fmt.Println(users[2])   // Kate
users[2] = "Katherine"
 
for _, value := range users{
    fmt.Println(value)

С помощью функции make() можно создать срез из нескольких элементов, которые будут иметь значения по умолчанию:
1
2
3
4
	
var users []string = make([]string, 3)
users[0] = "Tom"
users[1] = "Alice"
users[2] = "Bob"
Добавление в срез

Для добавления в срез применяется встроенная функция append(slice, value). Первый параметр функции - срез, в который надо добавить, а второй параметр - значение, которое нужно добавить. Результатом функции является увеличенный срез.
1
2
3
4
5
6
	
users := []string{"Tom", "Alice", "Kate"}
users = append(users, "Bob")
     
for _, value := range users{
    fmt.Println(value)
}
Оператор среза

Оператор среза s[i:j] создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1. При этом должно соблюдаться условие 0 <= i <= j <= cap(s). В качестве исходной последовательности, из которой берутся элементы, может использоваться массив, указатель на массив или другой срез. В итоге в полученном срезе будет j-i элементов.

Если значение i не указано, то применяется по умолчанию значение 0. Если значение j не указано, то вместо него используется длина исходной последовательности s.
1
2
3
4
5
6
7
8
9
	
// исходный массив
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
users1 := initialUsers[2:6]     // с 3-го по 6-й 
users2 := initialUsers[:4]      // с 1-го по 4-й
users3 := initialUsers[3:]      // с 4-го до конца
     
fmt.Println(users1)     // ["Kate", "Sam", "Tom", "Paul"]
fmt.Println(users2)     // ["Bob", "Alice", "Kate", "Sam"]
fmt.Println(users3)     // ["Sam", "Tom", "Paul", "Mike", "Robert"]
Удаление элемента

Что делать, если необходимо удалить какой-то определенный элемент? В этом случае мы можем комбинировать функцию append и оператор среза:
1
2
3
4
5
	
users := []string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
//удаляем 4-й элемент
var n = 3
users = append(users[:n], users[n+1:]...)   
fmt.Println(users)      //["Bob", "Alice", "Kate", "Tom", "Paul", "Mike", "Robert"]



51. Срез строк в Golang

Синтаксис среза массива также можно использовать для строк:
neptune := "Neptune"
tune := neptune[3:]
fmt.Println(tune) // Выводит: tune

Результатом среза строки является другая строка. Однако, присваивание нового значения neptune не изменит значения tune и наоборот:
neptune = "Poseidon"
fmt.Println(tune) // Выводит: tune



52. !!!!!!!!!!!!!!!!!!!!!!!! ВАЖНОЕ ПРО СРЕЗЫ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
planets := [...]string{ "Меркурий", "Венера", "Земля", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун",}
 
terrestrial := planets[0:4]
gasGiants := planets[4:6]
iceGiants := planets[6:8]
 
fmt.Println(terrestrial, gasGiants, iceGiants) // Выводит: [Меркурий Венера Земля Марс] [Юпитер Сатурн] [Уран Нептун]

Хотя terrestrial, gasGiants и iceGiants являются срезами, вы по-прежнему можете получать значение по индексу внутри срезов, как и внутри массивов:
fmt.Println(gasGiants[0]) // Выводит: Юпитер

Вы также можете разрезать массив, а потом полученный срез разрезать еще раз:
giants := planets[4:8]
gas := giants[0:2]
ice := giants[2:4]
fmt.Println(giants, gas, ice) // Выводит: [Юпитер Сатурн Уран Нептун] [Юпитер Сатурн] [Уран Нептун]

Срезы terrestrial, gasGiants, iceGiants, giants, gas и ice являются видами одного и того же массива planets. Присваивание нового значения к элементу среза МЕНЯЕТ БАЗОВЫЙ МАССИВ planets. Изменение будет видно и в других срезах:
iceGiantsMarkII := iceGiants // Копирует срез iceGiants (вид массива planets)
iceGiants[1] = "Посейдон"
fmt.Println(planets) // Выводит: [Меркурий Венера Земля Марс Юпитер Сатурн Уран Посейдон]
fmt.Println(iceGiants, iceGiantsMarkII, ice) // Выводит: [Уран Посейдон] [Уран Посейдон] [Уран Посейдон]



53. Длина и вместимость среза в Golang
Число элементов, что видны через срез, определяется его длиной. Если у слайса есть базовый массив, что большего размера, у среза остается вместимость для роста.

В следующем примере объявляется функция для вывода длины и вместимости среза:
package main
 
import "fmt"
 
// dump для длины, вместимости и содержимого среза
func dump(label string, slice []string) {
    fmt.Printf("%v: длина %v, вместимость %v %v\n", label, len(slice), cap(slice), slice)
}
 
func main() {
    dwarfs := []string{"Церера", "Плутон", "Хаумеа", "Макемаке", "Эрида"} 
    dump("dwarfs", dwarfs) // Выводит: dwarfs: длина 5, вместимость 5 [Церера Плутон Хаумеа Макемаке Эрида]                                             
    dump("dwarfs[1:2]", dwarfs[1:2]) // Выводит: dwarfs[1:2]: длина 1, вместимость 4 [Плутон]                                  
}

У среза, созданного через dwarfs[1:2], длина равна 1, и вместимость для 4 элементов.



54.Разбор функции append в Go
Через использование функции dump из Листинга 2 в следующем примере показано, как функция append влияет на вместимость.
dwarfs1 := []string{"Церера", "Плутон", "Хаумеа", "Макемаке", "Эрида"}  // Длина 5, вместимость 5
dwarfs2 := append(dwarfs1, "Оркус") // Длина 6, вместимость 10
dwarfs3 := append(dwarfs2, "Салация", "Квавар", "Седна") // Длина 9, вместимость 10
dwarfs1 := []string{"Церера", "Плутон", "Хаумеа", "Макемаке", "Эрида"}  // Длина 5, вместимость 5
dwarfs2 := append(dwarfs1, "Оркус") // Длина 6, вместимость 10
dwarfs3 := append(dwarfs2, "Салация", "Квавар", "Седна") // Длина 9, вместимость 10

В массиве, поддерживающем dwarfs1, недостаточно места (вместимости) для добавления элемента "Оркус", поэтому append копирует содержимое dwarfs1 к новому перемещенному массиву с двойной вместимостью. Срез dwarfs2 указывает на новый перемещенный массив. Добавленная вместимость нужна для создания места, что потребуется для следующей функции append.

Показать что, dwarfs2 и dwarfs3 ссылаются на иной массив, нежели dwarfs1, можно через изменение какого-то элемента и последующего вывода указанных трех срезов.

Задание для проверки:
При модификации элемента среза dwarfs3 из Листинга 3 изменятся ли срезы dwarfs2 и dwarfs1?
dwarfs3[1] = "Pluto!"

Ответ
dwarfs3 and dwarfs2 изменятся, но dwarfs1 останется прежним, так как он указывает на другой массив.



55. Трех-индексный срез в Golang

С появлением версии Go 1.2 был введен трех-индексный срез, что нужен для ограничения вместимости итогового среза. В следующем примере у terrestrial длина и вместимость 4. Добавление элемента "Церера" приводит к перемещению нового массива, оставляя массив planets не измененным.
Листинг 4
Go
planets := []string{
    "Меркурий", "Венера", "Земля", "Марс",
    "Юпитер", "Сатурн", "Уран", "Нептун",
}
 
terrestrial := planets[0:4:4] // Длина 4, вместимость 4
worlds := append(terrestrial, "Церера")
 
fmt.Println(planets) // Выводит: [Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун]

Если третий индекс не уточняется, вместимость terrestrial равна 8. Добавление элемента "Церера" не перемещает новый массив, а вместо этого переписывает "Юпитер":
Go
terrestrial = planets[0:4] // Длина 4, вместимость 8
worlds = append(terrestrial, "Церера")
 
fmt.Println(planets) // Выводит: [Меркурий Венера Земля Марс Церера Сатурн Уран Нептун]

Только если вы не хотите переписать элемент "Юпитер", нужно, чтобы при каждом срезе значился по умолчанию трех-индексный срез.

Вопрос для проверки:

Когда нужно использовать трех-индексный срез?
Ответ

Проще ответить на вопрос, когда не нужно использовать трех-индексный срез. Только если вам не нужно переписать элементы базового массива, безопаснее поставить по умолчанию трех-индексный срез.



56. Предварительное выделение срезов через make в Go

Если для append недостаточно вместимости, Go должен выделить новый массив и скопировать туда содержимое старого массива. Можно избежать лишних распределений и копий через предварительное выделение среза с помощью использования встроенной функции make.

Функция make в следующем примере уточняет длину (0) и вместимость (10) среза dwarfs. Перед заполнением dwarfs можно добавить до 10 элементов, после чего append должен будет выделить новый массив.

dwarfs := make([]string, 0, 10)
dwarfs = append(dwarfs, "Церера", "Плутно", "Хаумеа", "Макемаке", "Эрида")

Аргумент вместимости опционален. Начиная с длины и вместимости 10, вы можете использовать make([]string, 10). Каждый из 10 элементов содержит нулевое значение собственного типа, в данном случае это пустая строка. Встроенная функция append позволит добавить 11-й элемент.

Вопрос для проверки:
В чем преимущество создания среза через make?

Ответ
Предварительное выделение через make может установить начальную вместимость, тем самым можно избежать дополнительных перемещений и копий для увеличения базового массива.



57. Объявление вариативных функций в Golang

Printf и append являются вариативными функциями, так как они принимают переменное число аргументов. Для объявления вариативной функции используется многоточие (...) с последним параметром, как показано в примере ниже:

Параметр worlds является срезом строк, что содержит ноль или более аргументов, передаваемых в terraform:
Go
twoWorlds := terraform("Нью", "Венера", "Марс")
fmt.Println(twoWorlds) // Выводит: [Нью Венера Нью Марс]

Для передачи среза вместо множества аргументов, расширьте срез через многоточие:
Go
planets := []string{"Венера", "Марс", "Юпитер"}
newPlanets := terraform("Нью", planets...)
fmt.Println(newPlanets) // Выводит: [Нью Венера Нью Марс Нью Юпитер]

Если бы terraform модифицировала элементы параметра worlds, срез planets также зафиксировал бы эти изменения. Через использование newWorlds функция terraform избегает изменения и передачи аргументов.



58. Теперь добавим новый элемент в наш срез и посмотрим, как это повлияет на наш базовый массив:

baseSlice = append(baseSlice, 10)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 4 и емкостью 5: [5 6 7 10]
// true

Мы видим, что изменился не только наш срез, но и базовый массив, на который ссылается срез. Длина среза изменилась автоматически. А теперь повторим предыдущую операцию, но добавим столько элементов, чтобы емкости среза не хватило:

baseSlice = append(baseSlice, 11, 12, 13)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
// false

Мы видим, что базовый массив не изменился, а наш срез теперь ссылается на другой массив и имеет емкость больше длины. Почему так произошло? При добавлении элементов в срез Go проверяет, достаточно ли емкости среза для добавления новых элементов в срез (т.е. есть ли еще место в массиве, на котором основан срез). Если емкости не достаточно, то создается новый срез, основанный на массиве большего объема, в который копируются все элементы из старого среза, а также добавляются новые элементы.

Этот пример наглядно демонстрирует как устроены срезы в Go: создав один раз срез на основе массива достаточной нам длины, мы можем избежать операций выделения памяти при создании нового массива и копирования элементов из одного массива в другой.

Ещё такой момент
мы создали слайс на основе массива:     baseSlice := baseArray[5:8]

Базовый массив: [0 1 2 3 4 5 6 7 8 9]
Срез длиной 3 и емкостью 5: [5 6 7]

затем в массиве поменяли элемент:   baseArray[6] = 100 
в слайсе он тоже поменяется, т.к. элементы слайса и массива находятся в одном участке памяти.
Массив: [0 1 2 3 4 5 100 7 10 9]
 Срез длиной 3 и емкостью 5: [5 100 7]

превысим length и поменяем значение в baseArray:

baseSlice = append(baseSlice, 11, 12, 13)
 baseArray[7] = 200

тогда значение в срезе уже не изменится, т.к. при увеличении среза был создан новый, в другом участке памяти.

Массив: [0 1 2 3 4 5 100 200 10 9]
 Срез длиной 7 и емкостью 10: [5 100 7 10 11 12 13]



59. Почему нет такой, на первый взгляд, очевидной функции - удалить элемент среза? 
Допустим есть массив Array := [5]int{0, 1, 2, 3, 4}   и срез Slice :=  Array [1:4]  (то есть [1, 2, 3]).

Срез в памяти - это три значения:

    ссылка на последовательность данных (по сути - ссылка на элемент в массиве, с которого начинается срез). В нашем случае, это ссылка на элемент массива с индексом [1], то есть единичка. pointer := fmt.Sprintf("%p", Slice)

    len - длина среза, сколько элементов сейчас доступны в срезе. В нашем случае это - 3 (первый, второй и третий элементы массива). 
    len(Slice) == 3

    cap - объем, capacity, сколько ячеек памяти доступно впереди, дальше по массиву. В нашем случае от старта до конца массива 4 элемента: 1, 2, 3 и 4. cap(Slice) == 4.

И вот, решили мы удалить двойку из среза. Какой из элементов среза в памяти должен изменить компуктер? Ссылку на первый элемент? Длину? Объем? Ничего не подходит. Получается, чтобы удалить двойку из среза, нам нужно удалить ее из массива. А так нельзя, длина массивов неизменяема, можем только перезаписывать элементы.

Поэтому наш единственный (как я понимаю) выход - делать новый срез.

NewSlice := append(Slice[1:2], Slice[3:4])

!!!!!!!!!!!!!
Мы создали новый срез, для которого голанг создал в памяти новый массив [1, 3]. У нового среза все три элемента отличаются от старого среза. Ссылается он на первый элемент только что созданного массива, длина у него 2, емкость тоже 2.
!!!!!!!!!!!!!

Кстати, вот зачем нужна capacity при создании нового среза: если мы заранее не скажем голангу сколько ячеек памяти резервировать, то каждый раз при добавлении элементов он будет пересоздавать массив, перезаписывать все значения. А оно нам надо?

Поэтому просто так взять и удалить элемент из среза мы не можем, приходится делать новый срез - создавать новый или собирать по кусочкам из старого. 



60. Функция copy - копирование элементов среза
Сразу рассмотрим описание функции:
func copy(dst, src []Type) int

Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента

Почему мы явно указали длину создаваемого среза b? Потому что иначе функции было бы некуда копировать. Имей срез b длину 1, был бы скопирован 1 элемент из среза a.

Пример:
baseSlice := []int{1, 2, 3, 4, 5}

// так неправильно копировать

var emptySlice []int

copy(emptySlice,baseSlice)  // вернет меньший размер, в данном случае 0

// правильно так копировать

newSlice = make([]int, len(baseSlice), len(baseSlice))

copy(newSlice,baseSlice)



61. Особенности работы со срезами
Рассматривая эти темы помните о том, что срез по своей сути - указатель (подробнее про указатели во 2 модуле) на массив, а это влияет на его поведение при передаче в качестве аргумента в функцию:

func fnA(a [3]int) {
	a[1] = 15
}

func fnB(a []int) {
	a[1] = 15
}

func main() {
	a := [3]int{1, 2, 3}
	b := []int{1, 2, 3}

	fnA(a)
	fnB(b)

	fmt.Println(a) // [1 2 3]
	fmt.Println(b) // [1 15 3]
}

В приведенном примере мы создали 2 функции: fnA и fnB. Первая получает в качестве аргумента массив из 3-х элементов, вторая - срез. Обе функции изменяют второй элемент последовательности, но мы получаем совсем разный результат, потому что fnB работала с указателем на массив и изменила непосредственно сам массив, fnA же работала с копией массива, поэтому внутри функции был изменен элемент копии массива, а базовый массив остался неизменен.



62. Размер массива вычисляется во время компиляции программы, т.е. во время использования команд go run или go build. Команда fmt.Scan(&x) позволяет получить размер x только во время выполнения программы, т.е. когда вы запускаете ее исполняемый файл.

Получается, что размер массива в данной ситуации можно определить только прозапас (во время написания кода), скажем, на 1000 элементов, но тут уже вопрос в том, сколько программа будет занимать места в памяти. А вот срез тут подходит идеально, потому что с помощью команды make позволяет выделить столько памяти, сколько действительно нужно во время выполнения программы.



63. Интересные примеры программ:
Дано трехзначное число. Найдите сумму его цифр. 

package main
import ."fmt"

func main(){
    var a,b,c int
    Scanf("%1d%1d%1d",&a,&b,&c)
    Print(c+b+a)
}


Дано трехзначное число. Переверните его, а затем выведите. 
package main 

import "fmt"

func main(){
    var num [3]string
    fmt.Scanf("%1s%1s%1s", &num[2], &num[1], &num[0])
    fmt.Print(num[0]+num[1]+num[2])
}

	ИЛИ

package main
import ."fmt"

func main(){
    var a,b,c int
    Scanf("%1d%1d%1d",&a,&b,&c)
    Printf("%d%d%d",c,b,a)
}



!!!!!64. Функции!!!!!!
Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:
func имя_функции (список_параметров) (типы_возвращаемых_значений) {
    выполняемые_операторы
}

Пример функции:

func main() {
   hello()
}

func hello() {
    fmt.Println("Hello World")
}

Важно! Открывающая фигурная скобка должна располагаться на той же строке, что и объявление функции, иначе вы получите ошибку. Это сделано для единого стиля кода.

Напоминаем, краткое объявление переменных (a := 5) работает только внутри функций.

Полезности: если вы установили Go на компьютер, то можете использовать командную строку для изучения документации по той или иной стандартной функции. Например, если мы хотим узнать подробности о функции Println() мы можем ввести команду:
go doc fmt.Println или go doc fmt Println

Если вы хотите более подробно узнать о работе команды doc, можете ввести команду:
go help doc



65. Параметры функции
Через параметры функция получает входные данные. Параметры указываются в скобках после имени функции. Для каждого параметра указывается имя и тип (как для переменной). Друг от друга параметры разделяются запятыми. При вызове функции необходимо передать значения для всех ее параметров. Например, мы хотим использовать функцию, которая складывает два любых числа:

package main
import "fmt"
 
func main() {
    add(4, 5)   // x + y = 9
    add(20, 6)  // x + y = 26
}
 
func add(x int, y int){
    var z = x + y
    fmt.Println("x + y = ", z)
}

В функции main вызывается функция add. Так как функция принимает два параметра, то при вызове ей необходимо передать значения для этих параметров или два аргумента. Причем эти значения должны соответствовать параметрам по типу. То есть если параметр представляет тип int, то ему необходимо передать число.
Значения передаются по позиции. То есть первое значение получит первый параметр, второе значение - второй параметр и так далее. 

Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра, а предыдущие параметры также будут представлять этот тип:
package main
import "fmt"
 
func main() {
    add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
    var z = x + y
    var d = a + b + c
    fmt.Println("x + y = ", z)
    fmt.Println("a + b + c = ", d)
}

В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций или других функций, но при этом следует учитывать, что если аргументы в функцию передаются по значению, то они копируются:

package main
import "fmt"
 
func main() {
    var a = 8
    fmt.Println("a before: ", a)
    increment(a)
    fmt.Println("a after: ", a)
}
func increment(x int){
 
    fmt.Println("x before: ", x)
    x = x + 20
    fmt.Println("x after: ", x)
}

Вывод:

a before: 8
x before: 8
x after: 28
a after: 8

В данном случае в качестве аргумента в функцию increment передается значение переменной a. Параметр x получает это значение, и оно увеличивается на 20. Однако несмотря на то, что значение параметра x увеличилось, значение переменной a никак не изменилось. Потому что при вызове функции передается копия значения переменной.

Если хотите, чтобы при передаче переменной в функцию, ее значение не копировалось, а изменялось в соответствии с блоком действий внутри функции, тогда нужно передавать адрес этой переменной (при помощи оператора &). В этом случае в функции инкремент мы будем принимать параметром не инт, а указатель на адрес, в котором хранится инт: *int

func main() {
   var a = 8
   fmt.Println("a before: ", a)
   increment(&a)
   fmt.Println("a after: ", a)
}
func increment(x *int) {

   fmt.Println("x before: ", *x)
   *x = *x + 20
   fmt.Println("x after: ", *x)
}

На выходе получим:

a before:  8
x before:  8
x after:  28
a after:  28



66. Возвращение результата из функции

Функции могут возвращать результат. Для этого нужно после списка параметров функции указать тип возвращаемого результата. А в теле функции использовать оператор return, после которого указывается возвращаемое значение:

func имя_функции (список_параметров) тип_возвращаемого_значения {
    выполняемые_операторы
    return возвращаемое_значение
}

Например, мы хотим возвратить из функции сумму двух чисел:

package main
import "fmt"
 
func main() {
    var a = add(4, 5)   // 9
    var b = add(20, 6)  // 26
    fmt.Println(a)
    fmt.Println(b)
}
 
func add(x, y int) int {
    return x + y
}

Функция add возвращает значение типа int, поэтому данный тип указан после списка параметров. В самой функции после оператора return указывается возвращаемое значение. При этом данное значение может быть значением переменной, литералом, либо же, как в данном случае, результатом операции или вызова функции. То есть выражение x + y определяет возвращаемое значение.


В языке Go оператор `return` является необязательным в некоторых случаях, но его использование зависит от контекста и логики программы. Вот подробное объяснение с примерами.

### Когда оператор `return` обязателен:

1. **Возвращение значения из функции:**
   - В функции, которая должна вернуть значение, оператор `return` обязателен.
   ```go
   func add(a, b int) int {
       return a + b
   }
   ```

2. **Завершение выполнения функции:**
   - В функции, где нужно завершить выполнение и вернуть управление вызывающей функции.
   ```go
   func process() {
       // какой-то код
       if условие {
           return
       }
       // код, который не выполнится при условии
   }
   ```

### Спорные случаи:
2. **Условное возвращение:**
   - Иногда можно использовать `return` внутри условий для более чистого кода.
   ```go
   func isPositive(x int) bool {
       if x > 0 {
           return true
       }
       return false
   }
   ```

3. **Множественные возвращаемые значения:**
   - Если функция возвращает несколько значений, оператор `return` используется для их возврата.
   ```go
   func divide(a, b int) (int, error) {
       if b == 0 {
           return 0, errors.New("деление на ноль")
       }
       return a / b, nil
   }
   ```

### Когда можно не использовать `return`:
3. **При ошибке или панике:**
   - В случае ошибки или паники, программа может завершиться без явного `return`.
   ```go
   func example() {
       if err != nil {
           panic(err)
       }
       // код, который не выполнится при ошибке
   }
   ```

В целом, использование оператора `return` зависит от стиля программирования и читаемости кода. Главное правило - оператор `return` обязателен, если функция должна вернуть значение или завершиться в определенной точке.



67. В первом уроке по функциям было:
func имя_функции (список_параметров) (типы_возвращаемых_значений){
    выполняемые_операторы
}

тип_возвращаемого_значения берется в скобки () только когда там несколько значений?

Все верно, скобки требуются только тогда, когда возвращается несколько значений.



68. Возвращение нескольких значений

В Go функция может возвращать сразу несколько значений. В этом случае после списка параметров указывается в скобках список типов возвращаемых значений. А после оператора return располагаются через запятую все возвращаемые значения:

package main
import "fmt"
 
func main() {
    var age, name = add(4, 5, "Tom", "Simpson")
    fmt.Println(age)    // 9
    fmt.Println(name)   // Tom Simpson
}
 
func add(x, y int, firstName, lastName string) (int , string) {
    var z int = x + y
    var fullName = firstName + " " + lastName
    return z, fullName
}

Функция add принимает четыре параметра: два числа и две строки. Возвращает число (значение типа int) и строку. Возвращаемые значения указаны после оператора return.

Поскольку функция теперь возвращает два значения, то при вызове этой функции мы можем присвоить ее результат двум переменным:

var age, name = add(4, 5, "Tom", "Simpson")

Первое возвращаемое значение передается первой переменной age, а второе значение передается второй переменной name.

Альтернативный способ передачи переменным результатов функции:

age, name := add(4, 5, "Tom", "Simpson")

Игнорирование возвращаемых значений


Go позволяет проигнорировать все или определенные возвращаемые функцией значения, если мы не будем использовать их в дальнейшем. Для этого нам необходимо не присваивать им имена вообще либо заменить имя символом _. Рассмотрим это на примере:

func fn() (int, error) {
	// Какая-то полезная работа
	// ...
	return 0, nil
}
func ExampleIgnor() {
	fn()

	i, _ := fn()
	fmt.Println(i)

	_, err := fn()
	if err == nil {
		fmt.Println("Ошибок нет")
	}

	// Output:
	// 0
	// Ошибок нет
}

Здесь мы создали функцию-заглушку, возвращающую 2 значения: число и ошибка.

В первом примере мы проигнорировали оба возвращаемых значения, выполнив полезную работу функции (так мы часто делаем, когда используем функцию fmt.Print - игнорируя возвращаемые ею значения). 

Во втором примере мы проигнорировали сообщение об ошибке (не делайте так), а в третьем - только проверили, возвратила ли функция ошибку, проигнорировав возвращаемое число.



69. Функцию можно передавать переменное число аргументов. По моему это полезная информация.

func add(args ...int) int {



70. Функции с переменным количеством параметров (аргументов)
В завершении данной темы необходимо рассмотреть возможность передачи в функцию переменного количества аргументов. Для примера рассмотрим как выглядит функция Print из пакета fmt стандартной библиотеки:

func Print(a ...interface{}) (n int, err error) // interface мы рассмотрим в 3 модуле, это лишь для примера

Мы видим, что функция принимает аргумент a типа interface{}, но перед указанием типа имеется знак многоточия (…). Символ многоточия перед указанием типа указывает, что в функцию можно передать произвольное количество параметров указанного типа. Посмотрим, как это выглядит на практике:

func ExamplePrint() {
	fmt.Print(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}

Функция получила 5 аргументов произвольного типа (в примере это числа) и напечатала их все. Разберемся, как работает данная функция.

Аргумент с именем a ВОСПРИНЕМАЕТСЯ ФУНКЦИЕЙ КАК СРЕЗ ЭЛЕМЕНТОВ заданного типа interface{}, внутри функция работает с элементами этого среза соответствующим образом. Вот так эта функция могла бы выглядеть (под капотом реализация функции гораздо сложнее, но мы рассмотрим лишь необходимую нам часть функционала):

func myPrint(a ...interface{}) {
	for _, elem := range a {
		fmt.Printf("%d ", elem)
	}
}

func ExampleMyPrint() {
	myPrint(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}

Для примера мы реализовали функцию-обертку над fmt.Printf, чтобы показать, как обрабатывается переменное число аргументов.

Необходимо запомнить, что если функция принимает определенные аргументы и еще произвольное число аргументов определенного типа, то при объявлении функции эти «переменные» аргументы указываются в самом конце. Для примера:

func Fprint(w io.Writer, a ...interface{}) (n int, err error)

Эта функция принимает обязательный аргумент тип io.Writer и произвольное число аргументов типа interface{}.

В рамках данного урока вы неоднократно сталкивались с таким типом как interface{}, данная тема будет подробно рассмотрена в 3 модуле данного курса, пока же вы можете запомнить что использование этого типа (пустого интерфейса) означает, что функция может получить аргумент любого типа: строку, число, структуру и т.д.


Небольшое дополнение по использованию многоточия (...)

Как мы выяснили, знак многоточия слева от указания на тип передаваемого значения свидетельствует о возможности передать в функцию неопределенное количество аргументов указанного типа, внутри функции переданные аргументы будут обработаны как срез указанного в объявлении функции типа.

Однако язык Go предусматривает обратный способ использования многоточия - разворачивание (раскрытие) среза путем указания справа от среза знака многоточия. Приведу 2 примера:

func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}

 В первом примере мы создали срез типа []interface, а затем напечатали его в виде среза и в виде отдельных значений, входящих в него.

Важный вопрос, почему мы использовали тип []interface вместо типа []int? Это связано с механикой приведения типов в Go, в силу которой []int не является []interface. Но т.к. интерфейсы будут рассмотрены только в следующем модуле, рассмотрим эту проблему в дальнейшем.

В следующем примере мы создаем 2 среза типа []int, а затем используем встроенную функцию append для того, чтобы в элементы первого среза добавить элементы второго среза. Сигнатура функции приведена в самом примере в виде комментария: первый аргумент - срез указанного типа, далее следует неопределенное число аргументов указанного типа.

Использовав разворачивание среза s2 мы передадим в функцию сразу все его элементы.

func ExampleExpandSlice2() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}

	// append(slice []Type, elems ...Type) []Type

	// s1 = append(s1, s2) не сработает, т.к. второй и
	// последующие аргументы в нашем случае должны быть int

	s1 = append(s1, s2...)
	fmt.Println(s1)

	// Output:
	// [1 2 3 4 5 6 7 8 9 10]
}


Замечания 1:
Я проверил - ваш пример прекрасно работает с объявленным типом int параметра а (см. ниже). То есть, я не вижу смысла здесь путать студентов страшным словом interface. Ведь мы хотим здесь демонстрировать троеточие.

Также, здесь использование сложного Printf выглядит неуместным. Ведь если если параметр (a ...interface{}) может принять любой тип и количество, то зачем принудительно форматировать в данном примере вывод, если можно было бы показать это привычным Println? В голове возникает дополнительный не нужный вопрос, рассеивается внимание на ненужные нюансы, возникает неуверенность в том, что ты понимаешь правильно. 

func myPrint(a ...int) { //Работает с интом
	for _, elem := range a {
		fmt.Printf("%d ", elem) //Здесь не нужен Принтф
	}
}

func ExampleMyPrint() {
	myPrint(1, 2, 3, 4, 5)
}

* Еще я проверил ваше утверждение:

    "пока же вы можете запомнить что использование этого типа (пустого интерфейса) означает, что функция может получить аргумент любого типа: строку, число, структуру и т.д."

Я попробовал подложить строку в ваш пример с интерфейсом, и конечно же форматированный принт обругал меня:

func myPrint(a ...interface{}) {
	for _, elem := range a {
		fmt.Printf("%d ", elem)
	}
}

func main() {
	myPrint(1, 2, 3, 4, 5, "word")
}
//Output:
//1 2 3 4 5 %!d(string=word)

А вот когда я заменил его на fmt.Println, тогда действительно, он скушал и вывел мне и цифры, и слово:

func myPrint(a ...interface{}) {
	for _, elem := range a {
		fmt.Println(elem)
	}
}

func main() {
	myPrint(1, 2, 3, 4, 5, "word")
}

/*Output:

1
2
3
4
5
word*/



* Ну и, вишенка на торте:дд
    Важный вопрос, почему мы использовали тип []interface вместо типа []int? Это связано с механикой приведения типов в Go, в силу которой []int не является []interface.

Важный вопрос! А как объяснили! :))) Беру на вооружение:

Важный вопрос, почему мы использовали лошадь вместо собаки? Это связано с природой, в силу которой собака не является лошадью.

Надеюсь, примете с улыбкой и без злобы. :)

И-то-го:

    Я бы заменил тип interface на int в примерах, там где мы работаем только с int.
    Я бы добавил еще один пример, уже с типом interface, но заменил бы Printf на Println, чтобы показать, как подаваемый "винегрет" из интов и строк действительно кушается с помощью данного типа.
    

Замечание 2:
1. "* Я проверил - ваш пример прекрасно работает с объявленным типом int параметра а (см. ниже). То есть, я не вижу смысла здесь путать студентов страшным словом interface. Ведь мы хотим здесь демонстрировать троеточие." (с)

Думаю в данном случае авторы решили показать принцип работы троеточия на примере функции fmt.Print, о чем они и пишут в первом абзаце. А страшное слово interface объясняют чуть ниже:

    ... пока же вы можете запомнить что использование этого типа (пустого интерфейса) означает, что функция может получить аргумент любого типа: строку, число, структуру и т.д.

Насчёт неуместного использования Printf полностью согласен. Нужно было либо изменить тип входящего параметра с ...interface{} на ...int, либо использовать fmt.Print (не fmt.Println), чтобы полноценно имитировать работу этой функции в func myPrint(), что и хотят показать авторы.

2. "Я попробовал подложить строку в ваш пример с интерфейсом, и конечно же форматированный принт обругал меня:" (с)

Это потому что в fmt.Printf в данном примере используется спецификатор (глагол) %d, который выводит только десятичные числа.

3. "* Еще нашел неточность в тексте. ... Но корректно будет написать так: В первом примере мы создали срез типа interface{}, а затем... Потому что вы говорите о типе, а квадратные скобки не относятся к декларации типа.... Аналогично и дальше: там где вы говорите "тип" - не уместны уже квадратные скобки, потому что они обозначают собственно сам слайс, а не тип." (с)

Тут вы ошибаетесь. Go строго типизированный язык. И тип слайса/массива воспринимается языком именно как [] + тип содержащихся в слайсe/массиве переменных. А массивы с разным размером, но переменными одного типа внутри, так вообще считаются разными типами. Смотрите:

package main

import "fmt"

func main() {
	intSlice := []int{1, 2, 3, 4, 5}
	stringSlice := []string{"a", "b", "c", "d"}
	boolArray := [3]bool{true, false, true}
	float64Array := [4]float64{1.1, 2.2, 3.3, 4.4}
	interfaceSlice := []interface{}{intSlice, stringSlice, boolArray, float64Array}
	for _, elem := range interfaceSlice {
		fmt.Printf("type of %v is %T\n", elem, elem)
	}
	fmt.Printf("type of interfaceSlice (%v) is %T\n", interfaceSlice, interfaceSlice)
	// Output:
	// type of [1 2 3 4 5] is []int
	// type of [a b c d] is []string
	// type of [true false true] is [3]bool
	// type of [1.1 2.2 3.3 4.4] is [4]float64
	// type of interfaceSlice ([[1 2 3 4 5] [a b c d] [true false true] [1.1 2.2 3.3 4.4]]) is []interface{}

	// Дальнейший код даже не скомпилируется:
	// invalid operation: firstArray == secondArray (mismatched types [1]int and [2]int)
	firstArray := [1]int{}
	secondArray := [2]int{}
	fmt.Println(firstArray == secondArray)
}

4. "Вот здесь тоже не понятно:" (с)

В данном случае нам показывают еще 1 способ использования троеточия (в Go их несколько - подробнее) - "раскрытие" слайса (передаём в функцию сразу все его элементы) на примере функции append(), имеющей следующую сигнатуру: append(slice []Type, elems ...Type) []Type (т.е. мы видим что она может принимать различное количество переменных соответствующих типу переменных из которых состоит слайс в который мы и добавляем новые переменные).

Т.е. s1 = append(s1, s2)не сработает потому что слайс s1 состоит из переменных типа int, а тип переменной s2 []int. Другими словами, чтобы s1 = append(s1, s2) сработало, нужно чтобы тип s1 был [][]int (двумерный слайс с переменными типа int ). Пример:

package main

import "fmt"

func main() {
	intSlice := []int{1, 2, 3}
	intSlice2 := []int{4, 5, 6}
	sliceOfIntSlices := [][]int{}
	fmt.Printf("sliceOfIntSlices = %v\n", sliceOfIntSlices) // sliceOfIntSlices = []
	newIntSlice := append(intSlice, intSlice2...)
	fmt.Printf("newIntSlice = %v\n", newIntSlice) // newIntSlice = [1 2 3 4 5 6]
	sliceOfIntSlices = append(sliceOfIntSlices, intSlice, intSlice2)
	fmt.Printf("sliceOfIntSlices = %v\n", sliceOfIntSlices) // sliceOfIntSlices = [[1 2 3] [4 5 6]]
}

 5. "* Ну и, вишенка на торте:" (с)

По этому поводу (что  ↓ здесь ↓ имеют ввиду авторы курса) я очень развернуто ответил в этом комментарии.
    Важный вопрос, почему мы использовали тип []interface вместо типа []int? Это связано с механикой приведения типов в Go, в силу которой []int не является []interface.
Внутри любой функции принимающей произвольное количество параметров ( ...Type ) определенного типа, все входящие параметры добавляются в слайс типа []Type .

Т.е., например, внутри функции  func Print(a ...interface{}) переменная а становится слайсом и, соответственно, меняет свой тип на []interface{} .

Поэтому ↓ здесь ↓ авторы и используют слайс типа []interface{} а не []int

func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}

т.к. сигнатура функции fmt.Println  func Println(a ...any) (n int, err error) (c Go версии 1.18 any это alias interface{}), то и тип a внутри fmt.Println будет []interface{}, или []any (если у вас версия Go >= 1.18)

Соответственно, вызывая fmt.Println таким образом fmt.Println(s...) мы не сможем развернуть в неё слайс, тип которого не []any (он же []interface{} ).

А слайс типа []int в самом последнем примере авторы использовали в функции append() у которой следующая сигнатура: append(slice []Type, elems ...Type) []Type . В данном случае мы можем разворачивать в append() слайсы любого типа, хоть []any ( []interface{} ), хоть []int (что и сделали авторы), хоть слайс интовых слайсов ([][]int).

Т.е. чтобы пример авторов s1 = append(s1, s2...) сработал, мы можем сделать например следующее:

package main

import "fmt"

func main() {
	sliceOfIntSlices1 := [][]int{{1, 2, 3}}
	sliceOfIntSlices2 := [][]int{{4, 5, 6}, {7, 8, 9}}
	sliceOfIntSlices3 := append(sliceOfIntSlices1, sliceOfIntSlices2...)
	fmt.Println(sliceOfIntSlices3) // выведет [[1 2 3] [4 5 6] [7 8 9]]
}

Если более подробно по теме, то после того как в функцию передались все параметры через () как здесь myPrint(1, 2, 3, 4, 5) или через разворачивание слайса ( ... ) как здесь s1 = append(s1, s2...) , все эти параметры добавляются в слайс соответстующего типа который создается внутри любой функции которая принимает произвольное количество параметров ( ...Type ).



72. /* ЗАДАНИЕ:
 * Напишите функцию sumInt, получающую переменное число аргументов типа int,
 * и возвращающую количество переданных аргументов и их сумму.
 */

func sumInt(n ...int ) (c, s int) {
    for _, e := range n {
        c++
        s+=e
    }
    return
}

Это ещё одна фишка в синтаксисе языка. Позволяет работать с возращаемыми значениями функции без создания новых переменных в теле самой функции. В конце пишется ключевое слово return. Компилятор сам понимает что требуется вернуть из функции. 




73. Именованные возвращаемые значения
Возвращаемые значения Go могут быть названы. Если это так, они обрабатываются как переменные, определенные в верхней части функции.
Эти имена следует использовать для документирования значения возвращаемых значений.
A return без аргументов возвращает именованные возвращаемые значения. Это известно как «голое» возвращение.
Голые операторы return следует использовать только в коротких функциях, как в примере, показанном здесь. Они могут ухудшить читаемость в более длинных функциях.

package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}



74. Область видимости
Объявляя переменную, мы связываем ее имя с отражающей ее сущностью (числом, строкой, структурой). Область видимости является частью исходного кода, в которой использование объявленного имени ссылается на сущность из этого объявления.

В Go область видимости определяется лексическими блоками, к которым относятся:

    синтаксические блоки (последовательность инструкций, заключенных в фигурные скобки);
    прочие блоки, которые явно не ох­ватываются фигурными скобками в исходном тексте, но имеют схожее поведение: всеобщий блок, блок для каждого пакета, блок для каждого файла.

Имя, объявленное внутри синтаксического блока, невидимо вне блока, приведем пример:

package main

import "fmt"

func scope() {
	v := 1
	fmt.Print(v)
}

func main() {
    /*
     * Если мы не станем рассматривать в данном случае вопрос о времени жизни переменной,
     * а сконцентрируемся только на области видимости, то можем констатировать, что из
     * функции main мы не можем получить доступа к переменной v, объявленной в функции
     * scope.
     */
	scope()
	fmt.Print(v) // ошибка компиляции
}

Программа может содержать несколько объявлений одного и того же имени при условии, что все объявления находятся в различных лексических блоках. Например, можно объявить локальную переменную с тем же именем, что и переменная уровня пакета. Компилятор же, встретив ссылку на имя, ищет объявление, начиная с наиболее глу­боко вложенного внутреннего лексического блока и продолжая до всеобщего блока. Если компилятор не обнаруживает объявление, он сообщает об ошибке "необъявленное имя". Если имя объявлено и в наружном, и во внутреннем блоках, первым будет обнаружено внутреннее объявление. В этом случае говорят, что внутреннее объявле­ние затеняет внешнее:

func ExampleScope1() {
	var v int = 1

	{
		/*
		 * Здесь переменная из внешнего лексического блока затеняется
		 * переменной внутреннего лексического блока
		 */
		var v string = "2"
		fmt.Println(v)
	}

	fmt.Println(v)

	/*
	 * В примере мы объявили в отдельных лексических блоках переменные с одним именем и
	 * разными типами, а затем напечатали значения этих переменных.
	 */

	// Output:
	// 2
	// 1
}

Как упоминалось выше, не все лексические блоки соответствуют последователь­ностям операторов, помещенным в фигурные скобки, некоторые из них просто под­разумеваются. С областью видимости в пределах файла, пакета, глобальной областью видимости все более или менее просто, но этим рассматриваемая тема не ограничивается.

Цикл for создает два лексических блока: яв­ный блок для тела цикла и неявный блок, который дополнительно охватывает пере­менные, объявленные в инициализации цикла.

func ExampleScope2() {
	var i string = "Строка"

	/*
	 * Переменная i объявляется вне фигурных скобок, тем не менее это
	 * отдельная область видимости, к которой имеет доступ вторая область видимости,
	 * которая уже заключена в фигурные скобки
	 */
	for i := 0; i < 1; i++ {
		fmt.Println(i)
	}

	/*
	 * Аналогично примеру выше мы объявляем переменную i в области видимости
	 * вне фигурных скобок, а в теле цикла (отдельная область видимости) -
	 * затеняем переменную i
	 */
	for i := 0; i < 1; i++ {
		i := true
		fmt.Println(i)
	}

	fmt.Println(i)

	// Output:
	// 0
	// true
	// Строка
}

Аналогично конструкции цикла for такие неявные области видимости создаются конструкциями if, switch и select.



!!!!74. Функции первого класса, замыкания и анонимные функции!!!!
https://golangify.com/closures-anonymous-first-class-func



!!!!75. Пакеты!!!!
Весь код, который лежит в одной папке -- составляет пакет.
Внутри каждой программы, в package ты должен вписать навание той папки, в которой лежит код. Исключение является только main. Любая папка, содержащия код с package main, считается папкой main, ее настоящее название игнорируется. 
В main.go в package всегда прописывается main, вне зависимости от названия папки. Считатется, что папка содержащая main вне зависимости от своего оригинального названия в файловой системе, имеет название main (это нигде на деле не прописывается в файловой системе, только в параметре package). Так что весь код в этой папке должен прописываться с package main.

Весь код в языке Go организуется в пакеты. Пакеты представляют удобную организацию разделения кода на отдельные части или модули. Модульность позволяет определять один раз пакет с нужной функциональностью и потом использовать его многократно в различных программах.

Код пакета располагается в одном или нескольких файлах с расширением go. Для определения пакета применяется ключевое слово package. Например:

package main

import "fmt"
 
func main() {
     
    fmt.Println("Hello Go")
}

В данном случае пакет называется main. Определение пакета должно идти в начале файла.

Есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя main. Все остальные пакеты не являются исполняемыми. При этом пакет main должен содержать функцию main, которая является входной точкой в приложение.


Импорт пакетов:

Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора import. Например, в примере выше задействуется функциональность вывода сообщения на консоль с помощью функции Println, которая определена в пакете fmt. Соответственно чтобы использовать эту функцию, необходимо импортировать пакет fmt:

import "fmt"

Нередко программы подключают сразу несколько внешних пакетов. В этом случае можно последовательно импортировать каждый пакет:

package main

import "fmt"
import "math"
 
func main() {
     
    fmt.Println(math.Sqrt(16))  // 4
}

В данном случае подключается встроенный пакет math, который содержит функцию Sqrt(), возвращающую квадратный корень числа.

Либо чтобы сократить определение импорта пакетов можно заключить все пакеты в скобки:
package main

import (
    "fmt"
    "math"
)
 
func main() {
     
    fmt.Println(math.Sqrt(16))
}

Подобным образом мы можем импортировать как встроенные пакеты, так и свои собственные. Полный список встроенных пакетов в Go можно найти по адресу https://golang.org/pkg/.



Если вы знакомы с другими языками программирования, вам возможно знакомы конструкции типа таких:

using namespace std  // C++

from math import *   # python

Они позволяют использовать функции из импортируемых пакетов без указания имени самого пакета. Хотя это считается не самой лучшей практикой, тем не менее в Go есть аналогичный способ импорта - импорт с точкой:
package main

import . "fmt"

func main() {
    Println("Hello, Go!")
}
	
	ИЛИ

package main

import (
    . "fmt"
)

func main() {
    Println("Hello, Go!")
}

Импорт с точкой добавляет все экспортируемые поля пакета в текущий скоуп (точнее говоря область видимости файла). И теперь вы можете работать с полями импортированного пакет так, как будто они у вас в пакете.

ЗАМЕЧАНИЕ: фокус выше работает не только с одним, а с несколькими пакетами:
package main

import . "fmt"
import ."math"
 
func main() {
     
    Println(Sqrt(16))  // 4
}




Импорт c синонимом

Так же мы можем присвоить импорту "синоним" - то есть заменить fmt на другое слово при использовании этого пакета.

package main

import custom "fmt"

func main() {
	custom.Println("Hello!")
}

Пакеты импортируют, задавая синонимы, в нескольких случаях:
    Имя импортируемого пакета неудобное/некрасивое/… и хочется использовать другое;
    Имя импортируемого пересекается с именем другого пакета;
    Хочется бесшовно подменить пакет — интерфейсы пакетов должны совпадать. ( интерфейсы будут обсуждаться в следующем модуле, а структуры будут в этом, но чуть позже. Если коротко, то речь о том, что если в пакетах совпадают названия функций или структур и их методов, то можно заменить один пакет другим, но при этом не придется вносить изменения в код.)

Замечание: Такой подход часто используеться для замены стандартных библиотек golang на более оптимизированные и быстрые или более функциональные без необходимости переписывать код вашего приложения. Например в golang есть стандартный пакет log для логирования. Его можно заменить на более функциональный пакет logrus вот так.

import (
  log "github.com/sirupsen/logrus"
)	




!!!!78. Большие программы принято разделять на пакеты, чтобы упростить её чтение.!!!!
Создадим в проекте два файла: один - main.go, другой - main2.go. Но оба файла лежат в одном пакете, потому что мы прописали package main. Поэтому мы без импорта можем вызывать функции из другого файла.

//main.go
package main

func main(){
	test() --- вызываем функцию из другого файла, но лежащую в том же пакете
}			|
			|
//main2.go		|
package main		|
			|
func test() {    <-------	
}


!!!!Для запуска программы выше необходимо указать все файлы пакета main через пробел:

go run main.go main2.go




!!!!79.  Модули (относится к теме пакетов):!!!!
	https://go.dev/doc/code
	+ закладки по go (гугли "пакеты", "модули" и "$GOPATH")

Модуль -- пакет с пакетами. В файле go.mod прописываются все зависимости. Любой проект, даже без зависимостей требует сборки go.mod. Фактически все проекты твоего проекта составляют один большой модуль. Для 1-го проекта старабтся делать один go.mod файл, но это не обязательно. Но бывает, что  go.mod файлы являются вложенными: то есть есть пакете с go.mod, а внутри нее еще пакет с  go.mod, и это будет работать. То есть разделение на модули достаточно условное 
(Лучше еще раз уточни этот вопрос)!

80. Указатели:
Указатели представляют собой объекты, значением которых служат адреса других объектов (например, переменных).

Указатель определяется как обычная переменная, только перед типом данных ставится символ звездочки *. Например, определение указателя на объект типа int:
	
var p *int

Этому указателю можно присвоить адрес переменной типа int. Для получения адреса применяется операция &, после которой указывается имя переменной (&x).
	
package main
 
import "fmt"
 
func main() {
     
    var x int = 4       // определяем переменную
    var p *int          // определяем указатель 
    p = &x              // указатель получает адрес переменной
    fmt.Println(p)      // значение самого указателя - адрес переменной x
}

Здесь указатель p хранит адрес переменной x. Что важно, переменная x имеет тип int, и указатель p указывает именно на объект типа int. То есть должно быть соответствие по типу. И если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатеричное значение:

0xc0420120a0

В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0xc0420120a0. То есть в памяти компьютера есть адрес 0xc0420120a0, по которому располагается переменная x.

По адресу, который хранит указатель, мы получить значение переменной x. Для этого применяется операция * или операция разыменования. Результатом этой операции является значение переменной, на которую указывает указатель. Применим данную операцию и получим значение переменной x:
	
package main
 
import "fmt"
 
func main() {
     
    var x int = 4
    var p *int  = &x                // указатель получает адрес переменной
    fmt.Println("Address:", p)      // значение указателя - адрес переменной x
    fmt.Println("Value:", *p)       // значение переменной x
}

Консольный вывод:

Address: 0xc0420c058
Value: 4

И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:
	
var x int = 4
var p *int = &x
*p = 25
fmt.Println(x)      // 25

Для определения указателей можно использовать также сокращенную форму:
	
f := 2.3
pf := &f
     
fmt.Println("Address:", pf)
fmt.Println("Value:", *pf)
Пустой указатель


Если указателю не присвоен адрес какого-либо объекта, то такой указатель по умолчанию имеет значение nil (по сути отстутствие значения). Если мы попробуем получить значение по такому пустому указателю, то мы столкнемся с ошибкой:
	
var pf *float64
fmt.Println("Value:", *pf)  // ! ошибка, указатель не указывает на какой-либо объект

Поэтому при работе с указателями иногда бывает целесообразано проверять на значение nil:
	
var pf *float64
if pf != nil{
    fmt.Println("Value:", *pf)
}


Функция new
Переменная представляет именованный объект в памяти. Язык Go также позволяет создавать безымянные объекты - они также размещаются в памяти, но не имеют имени как переменные. Для этого применяется функция new(type). В эту функцию передается тип, объект которого надо создать. Функция возвращает указатель на созданный объект:
	
package main
 
import "fmt"
 
func main() {
     
    p := new(int) 
    fmt.Println("Value:", *p)       // Value: 0 - значение по умолчанию
    *p = 8                          // изменяем значение
    fmt.Println("Value:", *p)       // Value: 8
}

В данном случае указатель p будет иметь тип *int, поскольку он указывает на объект типа int. Создаваемый объект имеет значение по умолчанию (для типа int это число 0).

Объект, созданный с помощью функции new, ничем не отличается от обычной переменной. Единственное что, чтобы обратиться к этому объекту - получить или изменить его адрес, необходимо использовать указатель.



Также мы можем создать указатель на указатель.

package main

import "fmt"

func main() {
   a := 200
   b := &a
   *b++
   c := &b
   **c++ // указатель на указатель
   fmt.Println(a)
}

Вывод: 202 



!!!81. Структуры:!!!
С помощью структур эту программу можно сделать гораздо лучше. Структура — это тип, содержащий именованные поля. Например, мы можем представить круг таким образом:
type Circle struct {
    x float64
    y float64
    r float64
}

Ключевое слово type вводит новый тип. За ним следует имя нового типа Circle и ключевое слово struct, которое говорит, что мы определяем структуру и список полей внутри фигурных скобок. Каждое поле имеет имя и тип. Как и с функциями, мы можем объединять поля одного типа:
type Circle struct {
    x, y, r float64
}

Структура представляет собой удобный способ абстракции, когда мы "прячем" внутрь структуры (то есть нового типа данных) все детали, и начинаем оперировать структурой как цельной сущностью, работая с внутренними деталями только тогда, когда это необходимо. То есть, к примеру, от функции к функции мы передаем "Круг", в массивах можем хранить "Круги" и в целом оперировать "Кругами" как цельними объектами, и только когда нам надо совершить какое-то действие - узнать площадь круга, или понять, лежит ли заданная точка внутри определенного "Круга" - мы извлекаем из "Круга" нужные нам детали и проводим вычисления.

Пример:
package main

import "fmt"

type person struct {
    name string
    age  int
}

func newPerson(name string) *person {

    p := person{name: name}
    p.age = 42
    return &p
}

func main() {

    fmt.Println(person{"Bob", 20})

    fmt.Println(person{name: "Alice", age: 30})

    fmt.Println(person{name: "Fred"})

    fmt.Println(&person{name: "Ann", age: 40})

    fmt.Println(newPerson("Jon"))

    s := person{name: "Sean", age: 50}
    fmt.Println(s.name)

    sp := &s
    fmt.Println(sp.age)

    sp.age = 51
    fmt.Println(sp.age)

    dog := struct {
        name   string
        isGood bool
    }{
        "Rex",
        true,
    }
    fmt.Println(dog)
}

Вывод: 
$ go run structs.go
{Bob 20}
{Alice 30}
{Fred 0}
&{Ann 40}
&{Jon 42}
Sean
50
51
{Rex true}

82. Инициализация структуры:
Мы можем создать экземпляр нового типа Circle несколькими способами:
var c Circle
// или
c := Circle{}

Подобно другим типам данных, будет создана локальная переменная типа Circle, чьи поля по умолчанию будут равны нулю (0 для int, 0.0 для float, "" для string, nil для указателей, …). Также, для создания экземпляра можно использовать функцию new.
c := new(Circle)
Это выделит память для всех полей, присвоит каждому из них нулевое значение и вернет указатель (*Circle).

Часто, при создании структуры мы хотим присвоить полям структуры какие-нибудь значения. Существует два способа сделать это. Первый способ:
c := Circle{x: 0, y: 0, r: 5}
Второй способ — мы можем опустить имена полей, если мы знаем порядок в котором они определены:
c := Circle{0, 0, 5}

Пример 1:
type coord struct {
   x, y float32
}

type Circle struct {
   center coord
   radius float32
}

circle1 := Circle{
   center: coord{4, 5},
   radius: 7,
}

Пример 2:
По поводу разницы между созданием структур разным способом:
c1 := Circle{} 
c2 := new(Circle)
для себя понял так, с1 - содержит структуру, а с2 - указатель на структуру. Если имеется функция в которой мы меняем структуру, то вызов этой функции будет зависеть от того как мы создали структуру:

package main
import "fmt"

type Circle struct {
	x, y, r float64
}

func f1(c *Circle){
	c.x = 100
	c.y = 100
	c.r = 100
	fmt.Println("f1 ", c) // f1  &{100 100 100}
}

func main(){
	c1 := Circle{}
	c2 := new(Circle)
		
	f1(&c1)
	f1(c2)
	
	fmt.Println("main c1 ", c1)  // main c1  {100 100 100}
	fmt.Println("main c2 ", *c2) // main c2  {100 100 100}
}



83. Поля структур:
Получить доступ к полям можно с помощью оператора . (точка):

fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5

Давайте изменим функцию circleArea так, чтобы она использовала структуруCircle:

func circleArea(c Circle) float64 {
    return math.Pi * c.r * c.r
}

В функции main у нас будет:

c := Circle{0, 0, 5}
fmt.Println(circleArea(c))

Очень важно помнить о том, что аргументы в Go всегда копируются. Если мы попытаемся изменить любое поле в функции circleArea, оригинальная переменная не изменится. Именно поэтому мы будем писать функции используя указатели:

func circleArea(c *Circle) float64 {
    return math.Pi * c.r * c.r
}

И изменим main:
c := Circle{0, 0, 5}
fmt.Println(circleArea(&c))



84. Поля в структурах:
Получить доступ к полям можно с помощью оператора . (точка):
fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5

Давайте изменим функцию circleArea так, чтобы она использовала структуруCircle:
func circleArea(c Circle) float64 {
    return math.Pi * c.r * c.r
}

В функции main у нас будет:
c := Circle{0, 0, 5}
fmt.Println(circleArea(c))

Очень важно помнить о том, что аргументы в Go всегда копируются. Если мы попытаемся изменить любое поле в функции circleArea, оригинальная переменная не изменится. Именно поэтому мы будем писать функции используя указатели:
func circleArea(c *Circle) float64 {
    return math.Pi * c.r * c.r
}

И изменим main:
c := Circle{0, 0, 5}
fmt.Println(circleArea(&c))

Копирование занимает время. Когда структура большая или копирование производится много раз (или и то и другое вместе), снижается производительность. Скопировать указатель в большинстве случаев гораздо быстрее. Оптимизирующий компилятор может передавать указатель в регистре.

Пример:
package main

import "fmt"

type Circle struct {
	x, y, r float64
}

func main() {
	c := Circle{1, 2, 3}
	fmt.Println("call func with linked arguments do return: ", test1(&c))
	fmt.Println("after", c)

	v := Circle{1, 2, 3}
	fmt.Println("call func with not linked arguments do return: ", test2(v))
	fmt.Println("after", v)
}

func test1(circle *Circle) *Circle {
	circle.r *= 2
	return circle
}

func test2(circle Circle) Circle {
	circle.r *= 2
	return circle
}

Мне стало понятнее вот так

call func with linked arguments do return:  &{1 2 6}
after {1 2 6}
call func with not linked arguments do return:  {1 2 6}
after {1 2 3}



!!!!85. Методы!!!!
Метод представляет функцию, связанную с определенным типом. Методы определяются также как и обычные функции за тем исключением, что в определении метода также необходимо указать получателя или receiver. Получатель - это параметр того типа, к которому прикрепляется метод:	
func (имя_параметра тип_получателя) имя_метода (параметры) (типы_возвращаемых_результатов){
    тело_метода
}

Допустим, у нас будет определен именованный тип, представляющий срез из строк:
type library []string

Для вывода всех элементов из среза мы можем определить следующий метод:	
func (l library) print(){
 
    for _, val := range l{
        fmt.Println(val)
    }
}

Та часть, которая расположена между ключевым словом func и именем метода и представляет определение получателя, для которого будет определен этот метод: (l library). Используя параметр получателя (в данном случае l), мы можем обращаться к получателю. Например, в нашем случае получатель представляет срез - набор объектов. С помощью цикла for можно пройтись по этому срезу и вывести все его элементы на консоль.

Поскольку print представляет именно метод, который определен для типа library, а не обычную функцию, то мы можем вызвать этот метод у любого объекта типа library:	
var lib library = library{ "Book1", "Book2", "Book3" }
lib.print()

lib является объектом типа library, поэтому для него мы можем вызвать метод print. В данном случае объект lib - это и будет то значение, которое будет передаваться в функцию print через параметр (l library).
Методы структур

Подобным образом мы можем определять методы и для структур:	
package main
 
import "fmt"
 
type person struct{
    name string
    age int
}
func (p person) print(){
    fmt.Println("Имя:", p.name)
    fmt.Println("Возраст:", p.age)
}
 
func (p person) eat(meal string){
    fmt.Println(p.name, "ест", meal)
}
 
func main() {
     
    var tom = person { name: "Tom", age: 24 }
    tom.print()
    tom.eat("борщ с капустой, но не красный")
}

Консольный вывод данной программы:
Имя: Tom
Возраст: 24
Tom ест борщ с капустой, но не красный

В данном случае для структуры person определены две функции: print и eat. Функция print выводит информацию о текущем объекте person. А функция eat имитирует употребление пищи. Каждая из этих функций определяет объект и тип структуры, к которой функция относится:	
func (p person) имя_функции

С помощью объекта p мы можем обращаться к свойствам структуры person. В остальном это обычные функции, которые могут принимать параметры и возвращать результат.

Для обращения к функциям структуры указывается переменная структуры и через точку идет вызов функциии.	
tom.print()
tom.eat("борщ")

В данном случае tom - это и будет объект p person в определении функции.



Синтаксис для определения метода аналогичен синтаксису для определения функции. Единственная разница — это добавление дополнительного параметра после ключевого слова func для указания получателя метода. Получатель — это объявление типа, для которого вы хотите определить метод. В следующем примере определяется метод для типа структуры:
package main

import "fmt"

type Creature struct {
	Name     string
	Greeting string
}

func (c Creature) Greet() {
	fmt.Printf("%s says %s", c.Name, c.Greeting)
}

func main() {
	sammy := Creature{
		Name:     "Sammy",
		Greeting: "Hello!",
	}
	Creature.Greet(sammy)
}

Если вы запустите этот код, вывод будет выглядеть следующим образом:

Output
Sammy says Hello!

Мы создали структуру с именем Creature с полями типа string для Name и Greeting. Эта структура Creature имеет один определенный метод Greet. В объявлении получателя мы присвоили экземпляр Creature для переменной с, чтобы мы могли обращаться к полям Creature, когда мы будем собирать сообщение приветствия в fmt.Printf.

В других языках вызовы получателя метода обычно выполняются с помощью ключевого слова (например, this или self). Go рассматривает получателя как обычную переменную, поэтому вы можете использовать любое имя на ваше усмотрение. Сообществом для данного параметра используется стиль, согласно которому имя типа получателя должно начинаться со строчной буквы. В данном примере мы использовали c, поскольку типом получателя является Creature.

Внутри тела main мы создали экземпляр Creature и указали значения для полей Name и Greeting. Здесь мы вызвали метод Greet, объединив имя типа и имя метода с помощью оператора . и предоставив экземпляр Creature в качестве первого аргумента.

Go предоставляет другой, более удобный способ вызова методов для экземпляров структуры, как показано в данном примере:

package main

import "fmt"

type Creature struct {
	Name     string
	Greeting string
}

func (c Creature) Greet() {
	fmt.Printf("%s says %s", c.Name, c.Greeting)
}

func main() {
	sammy := Creature{
		Name:     "Sammy",
		Greeting: "Hello!",
	}
	sammy.Greet()
}

Если вы запустите его, вывод будет таким же, как и в предыдущем примере:

Output
Sammy says Hello!





Небольшое пояснение для тех, кто не понял разницы с примером.

Функция - более "широкое понятие". Она является самостоятельной единицей, может быть вызвана откуда угодно, имеет входные и выходные параметры (так и взаимодействует с "внешним миром"), если нужно, возвращаемое значение.

Метод - можно назвать функцией, но не наоборот. Нужно понимать отличия этих двух понятий. Метод  для своей работы может использовать поля объекта и/или класса, в котором определен, напрямую, без необходимости передавать их во входных параметрах. Это похоже на использование глобальных переменных в функциях, но в отличие от глобальных переменных, метод может получать прямой доступ только к членам класса. Метод привязан к классу, если он статический, или объекту и может быть вызван только через этот класс или объект.

Это общие правила для ООП языков.

Если говорить именно о GO:
1. Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

2. Метод представляет функцию, связанную с определенным типом. Методы определяются также как и обычные функции за тем исключением, что в определении метода также необходимо указать получателя или receiver. Получатель - это параметр того типа, к которому прикрепляется метод. Проще говоря: Метод - это функция с получателем.

Как объявляется функция:
func имя_функции (список_параметров) (типы_возвращаемых_значений){

    выполняемые_операторы

}

А вот так метод:
func (имя_параметра тип_получателя) имя_метода (параметры) (типы_возвращаемых_результатов){

    тело_метода

}

ВСЁ РАВНО НЕ ПОНЯТНО?

Давайте разберём на примере. Задача: Есть структура Person у которой есть параметры имени и возраста. Задача написать метод/функцию, которая выводит имя и возраст.

И так, как это выглядит, если бы мы делали через функцию:
package main

import "fmt"

//Создаем структуру 

type Person struct { 
   name string 
   age int
 }

// Создаем функцию, которая принимает строковое и целочисленное значение и выводит их
func aboutPerson(name string, age int) {
   fmt.Println(name, age)
}

//Создаем структуру tom, а затем обращаемся к функции, передавая параметры имени и возраста tom
func main() {
   var tom = Person{name: "Том", age: 35}
   aboutPerson(tom.name, tom.age)

} //ВЫВОД: Том 35

Вроде бы все работает, но давайте тоже самое через метод:
package main

import "fmt"

// Структура

type Person struct {
   name string
   age  int
}

// Создание метода

func (p Person) aboutPerson() {
   fmt.Println(p.name, p.age)
}

//Создаем структуру tom, а затем обращаемся к методу
func main() {
   var tom = Person{name: "Том", age: 35}
   tom.aboutPerson()

} //ВЫВОД: Том 35

Как мы видим, использование метода в этом случае более обосновано. Код становится более понятным, не нужно каждый раз вручную прописывать параметры функции, обращаясь к параметрам структуры через точку, метод и так умеет с ними работать. Еще более понятным это становится на большем количестве:

func main() {
   var tom = Person{name: "Том", age: 35}
   var andrey = Person{name: "Андрей", age: 27}
   var leha = Person{name: "Лёха", age: 23}

   tom.aboutPerson()
   andrey.aboutPerson()
   leha.aboutPerson()
}

А теперь представь, как было бы муторно прописывать параметры функции для каждого человека, чтобы просто вывести его имя и возраст. Более того, в функцию AboutPerson из первого примера, можно передать вообще любые значения, без привязки к структуре или конкретному множеству, что ни есть хорошо в данном случае.

Несмотря на то, что программа стала лучше, мы все еще можем значительно её улучшить, используя метод — функцию особого типа:
func (c *Circle) area() float64 {
    return math.Pi * c.r * c.r
}


Между ключевым словом func и именем функции мы добавили «получателя». Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора .:
fmt.Println(c.area())

Это гораздо проще прочесть, нам не нужно использовать оператор & (Go автоматически предоставляет доступ к указателю на Circle для этого метода), и поскольку эта функция может быть использована только для Circle мы можем назвать её просто area.

Давайте сделаем то же самое с прямоугольником:
type Rectangle struct {
    x1, y1, x2, y2 float64
}
func (r *Rectangle) area() float64 {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    return l * w
}

В main будет написано:
r := Rectangle{0, 0, 10, 10}
fmt.Println(r.area())

Пример 1:
package main

import "fmt"

type Circle struct {
	x, y, r float64
}

func main() {
	a := Circle{1, 2, 3}
	fmt.Println("Call linked method", a.testLinked())
	fmt.Println("after", a)
	b := Circle{1, 2, 3}
	fmt.Println("Call method", b.test())
	fmt.Println("after", b)
}

func (c *Circle) testLinked() *Circle {
	c.r = 123
	return c
}

func (c Circle) test() Circle {
	c.r = 123
	return c
}

Так же показался более очевидным этот пример; вывод:

Call linked method &{1 2 123}
after {1 2 123}
Call method {1 2 123}
after {1 2 3}


Пример 2:
package main

import "fmt"

type rect struct {
    width, height int
}

func (r *rect) area() int {
    return r.width * r.height
}

func (r rect) perim() int {
    return 2*r.width + 2*r.height
}

func main() {
    r := rect{width: 10, height: 5}

    fmt.Println("area: ", r.area())
    fmt.Println("perim:", r.perim())

    rp := &r
    fmt.Println("area: ", rp.area())
    fmt.Println("perim:", rp.perim())
}

Вывод:
$ go run methods.go 
area:  50
perim: 30
area:  50
perim: 30

Методы могут быть определены как для указателя, так и для значения типы получателей. Вот пример получателя значений. Здесь мы вызываем 2 метода, определенных для нашей структуры. Go автоматически обрабатывает преобразование между значениями и указателями для вызовов методов. Возможно, вы захотите использовать тип получателя указателя, чтобы избежать копирования при вызовах метода или позволить методу изменять структуру получения. 
 


86. Встроенные типы структур:
Обычно, поля структур представляют отношения принадлежности (включения). Например, у Circle (круга) есть radius (радиус). Предположим, у нас есть структура Person (личность):
type Person struct {
    Name string
}
func (p *Person) Talk() {
    fmt.Println("Hi, my name is", p.Name)
}

И если мы хотим создать новую структуру Android, то можем сделать так:
type Android struct {
    Person Person
    Model string
}

Это будет работать, но мы можем захотеть создать другое отношение. Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью? Go поддерживает подобные отношения с помощью встраиваемых типов, также называемых анонимными полями. Выглядят они так:
type Android struct {
    Person
    Model string
}

Мы использовали тип (Person) и не написали его имя. Объявленная таким способом структура доступна через имя типа:
a := new(Android)
a.Person.Talk()

Но мы также можем вызвать любой метод Person прямо из Android:
a := new(Android)
a.Talk()

Это отношение работает достаточно интуитивно: личности могут говорить, андроид это личность, значит андроид может говорить.

Также мы можем при создании инициализировать нужные переменные:
var a = Android{
	Model: "model",
	Person: Person {
		Name: "name",
	},
}

Коротко говоря, в ООП есть понятие наследование, которое реализуется посредством классов. В Go ООП нет, но тут свой подход, который заменяет наследование, - это агрегация. Как мы знаем, каждый сотрудник является человеком, но не каждый человек сотрудник. То есть, если мы создадим 2 структуры: Person и Employee, то логично, что у Employee должен быть тот же функционал, что и Person, но только немного усовершенствован. Мы, чтобы не переписывать весь код из Person, можем объявить одним из свойств Employee, структуру Person. Таким образом, при создании объекта Employee, мы создадим и объект Person, который будет доступен через объект Employee. Тоже самое мы проделываем и в этом уроки, но с Android и Person. Еще пример агрегации - Компьютер и принтер, без принтера компьютер может работать, но не наоборот.
Вышенаписанное называется композицией, которая еще называется агрегацией по значению.

Замеччание: 
Разницу когда пишем Person Person или просто Person.  разница в том, как мы будем обращаться к свойствам и методам вложенной структуры:

    структура Android из примера может иметь свойство Person (имя поля может быть другим) с типом Person (отношение Android имеет Person) - здесь вы напишите ИмяПоля Person
    в структуру Android можно встроить структуру Person (отношение Android является Person) - а здесь просто Person

Тогда в первом случае метод Talk() будет вызван так: a.Person.Talk(), а во втором - a.Talk().

Вопрос о том, как делать лучше, не стоит, потому что в разных случаях применяться могут разные варианты.

Вот отличный пример это демонстрирующий:
package main

import "fmt"

type subStruct struct {
	field int
}

func (s *subStruct) subStructMethod() int {
	return s.field
}

type firstStruct struct {
	subStruct
}

type secondStruct struct {
	sub subStruct
}

func main() {
	s1 := firstStruct{subStruct{field: 11}}
	s2 := secondStruct{subStruct{field: 12}}

	fmt.Println(s1.subStructMethod(), s1.field, s1.subStruct.field)   // 11 11 11
	fmt.Println(s2.sub.subStructMethod(), s2.sub.field, s2.sub.field) // 12 12 12  (последней строчке два раза одинаковый вызов s2.sub.field, это //случайно получилось, в предпоследней строке можно к свойству обратиться двумя способами, во втором - только одним. Или же там планировалось метод вызвать, //он вполне себе будет работать - прошло несколько месяцев с обсуждения этой темы, я сейчас уже не вспомню.)
}													


87. Обработка ошибок:
Обработка ошибок — это процесс обнаружения ситуаций, когда ваша программа находится в неожиданном состоянии, а также принятие мер для записи диагностической информации, которая будет полезна при последующей отладке.

В отличие от других языков программирования, где разработчикам нужно обрабатывать ошибки с помощью специального синтаксиса (try catch/try except), ошибки в Go — это значения с типом error, возвращаемые функциями, как и любые другие значения. Для обработки ошибок в Go мы должны проверить ошибки, которые могут возвращать функции, решить, существует ли ошибка, а также принять надлежащие меры для защиты данных и сообщить пользователям или операторам, что произошла ошибка.

Самая простая обработка - это проверка ошибки на пустоту. Многие методы и функции в GO при вызове возвращают не только нужный результат, но и ошибку. К примеру: у нас есть функция которая делит число на другое число и ввод переменной.

package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	fmt.Scan(&input)
	fmt.Println(divide(input, 5)) //Выведем результат
}

Однако, надо учесть, что пользователь может быть невнимательным и подать на вход все, кроме int, что может сломать нашу программу. Предотвратим это, используя специальную конструкцию:

package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	_, err := fmt.Scan(&input) // функция Scan возвращает два параметра, но нам сейчас важно проверить только ошибку
	if err != nil {
		fmt.Println("Проверьте типы входных параметров")
	} else {
		fmt.Println(divide(input, 5)) //Выведем результат, если ошибок нет
	}
}


nil - это пустота (null в других языках)

Если переменная "err" не пустая - произошла ошибка, иначе - всё хорошо.

Не обрабатывать ошибки  - плохая практика, именно поэтому IDE (например Goland) всегда подскажет, что функция возвращает ошибку которую вы не обработали.


88. Создание ошибок
Прежде чем мы сможем обработать ошибку, нам нужно ее создать. Стандартная библиотека предоставляет две встроенные функции для создания ошибок: errors.New и fmt.Errorf. Обе эти функции позволяют нам указывать настраиваемое сообщение об ошибке, которое вы можете отображать вашим пользователям.

errors.New получает один аргумент — сообщение об ошибке в виде строки, которую вы можете настроить, чтобы предупредить ваших пользователей о том, что пошло не так.

Попробуйте запустить следующий пример, чтобы увидеть ошибку, созданную с помощью errors.New, которая выполняет стандартный вывод:

package main

import (
	"errors"
	"fmt"
)

func main() {
	err := errors.New("barnacles")
	fmt.Println("Sammy says:", err)
}

Output
Sammy says: barnacles

Мы использовали функцию errors.New из стандартной библиотеки для создания нового сообщения об ошибке со строкой "barnacles" в качестве сообщения об ошибке. Мы выполняли требование конвенции, используя строчные буквы для сообщения об ошибке, как показано в руководстве по стилю для языка программирования Go.

Наконец, мы использовали функцию fmt.Println для объединения сообщения о ошибке со строкой "Sammy says:".

Функция fmt.Errorf позволяет динамически создавать сообщение об ошибке. Ее первый аргумент — это строка, которая содержит ваше сообщение об ошибке с заполнителями, такими как %s для строки и %d для целых чисел. fmt.Errorf интерполирует аргументы, которые находятся за этой форматированной строкой, на эти заполнители по порядку:

package main

import (
	"fmt"
	"time"
)

func main() {
	err := fmt.Errorf("error occurred at: %v", time.Now())
	fmt.Println("An error happened:", err)
}

Output
An error happened: Error occurred at: 2019-07-11 16:52:42.532621 -0400 EDT m=+0.000137103

Мы использовали функцию fmt.Errorf для создания сообщения об ошибке, которое будет включать текущее время. Форматированная строка, которую мы предоставили fmt.Errorf, содержит директиву форматирования %v, которая указывает fmt.Errorf использовать формат по умолчанию для первого аргумента, предоставленного после форматированной строки. Этот аргумент будет текущим временем, предоставленным функцией time.Now из стандартной библиотеки. Как и в предыдущем примере, мы добавляем в сообщение об ошибке короткий префикс и выводим результат стандартным образом, используя fmt.Println.

 В языке Go разница между функциями errors.New и fmt.Errorf заключается в том, как они используются для создания ошибок.

    errors.New:
        errors.New просто создает новую ошибку с заданным текстом.
        Пример:

        import "errors"

        err := errors.New("Это ошибка")

    fmt.Errorf:
        fmt.Errorf позволяет форматировать строку ошибки, используя форматирование подобное Printf.
        Пример:

        import "fmt"

        err := fmt.Errorf("Ошибка с кодом: %d", 404)

Таким образом, errors.New удобен для создания простых ошибок с фиксированным текстом, в то время как fmt.Errorf полезен, когда требуется форматирование строки ошибки с дополнительными значениями.


!!!!89. Обработка ошибок (ошибки)!!!!
Обычно вы будете видеть ошибки, создаваемые таким образом для использования сразу же без какой-либо цели, как показано в предыдущем примере. На практике гораздо чаще функция создает ошибку и возвращает ее, когда что-то происходит неправильно. Вызывающий эту функцию будет использовать оператор if, чтобы убедиться, что ошибка присутствует, или nil, неинициализированное значение.

В следующем примере содержится функция, которая всегда возвращает ошибку. Обратите внимание, что при запуске программы выводится тот же результат, что и в предыдущем примере, хотя функция на этот раз возвращает ошибку. Объявление ошибки в другом месте не изменяет сообщение об ошибке.

package main

import (
	"errors"
	"fmt"
)

func boom() error {
	return errors.New("barnacles")
}

func main() {
	err := boom()

	if err != nil {
		fmt.Println("An error occurred:", err)
		return
	}
	fmt.Println("Anchors away!")
}

Output
An error occurred: barnacles

Здесь мы определяем функцию под именем boom(), которая возвращает error, которую мы создаем с помощью errors.New. Затем мы вызываем эту функцию и захватываем ошибку в строке err := boom(). После получения этой ошибки мы проверяем, присутствует ли она, с помощью условия if err ! = nil. Здесь условие всегда выполняет оценку на true, поскольку мы всегда возвращаем error из boom().

Это не всегда так, поэтому лучше использовать логику, обрабатывающую случаи, когда ошибка отсутствует (nil) и случаи, когда ошибка есть. Когда ошибка существует, мы используем fmt.Println для вывода ошибки вместе с префиксом, как мы делали в предыдущих примерах. Наконец, мы используем оператор return, чтобы пропустить выполнение fmt.Println("Anchors away!"), поскольку этот код следует выполнять только при отсутствии ошибок.

Примечание: конструкция if err !​​​ = nil, показанная в последнем примере, является стандартной практикой обработки ошибок в языке программирования Go. Если функция может генерировать ошибку, важно использовать оператор if, чтобы проверить наличие ошибки. Таким образом, код Go естественным образом имеет логику "happy path"на первом уровне условия и логику "sad path" на втором уровне условия.

Операторы if имеют опциональное условие назначения, которое можно использовать для сжатия вызова функции и обработки ее ошибок.

Запустите следующую программу, чтобы увидеть те же результаты, что и в нашем предыдущем примере, но в этот раз с помощью оператора if для сокращения количества шаблонного кода:

package main

import (
	"errors"
	"fmt"
)

func boom() error {
	return errors.New("barnacles")
}

func main() {
	if err := boom(); err != nil {
		fmt.Println("An error occurred:", err)
		return
	}
	fmt.Println("Anchors away!")
}

Output
An error occurred: barnacles

Как и ранее, у нас есть функция boom(), которая всегда возвращает ошибку. Мы присвоим ошибку, возвращаемую boom(), переменной err в первой части оператора if. Эта переменная err будет доступна во второй части оператора if после точки с запятой. Мы должны убедиться в наличии ошибки и вывести нашу ошибку с коротким префиксом, как мы уже делали до этого.



i Возврат ошибок вместе со значениями
Функции, возвращающие одно значение ошибки, часто относятся к функциям, выполняющим изменения с сохранением состояния, например, вставляющим строки в базу данных. Также вы можете написать функции, возвращающие значение при успешном завершении работы и ошибку, если работа функции завершилась сбоем. Go позволяет функциям возвращать более одного результата, т. е. они могут использоваться для возврата как значения, так и типа ошибки.

Чтобы создать функцию, которая возвращает несколько значений, мы перечислим типы всех возвращаемых значений внутри скобок в сигнатуре функции. Например, функция capitalize, которая возвращает string и error, будет объявлена следующим образом: func capitalize(name string) (string, error) {}. Часть (string, error) сообщает компилятору Go, что эта функция возвращает строку и ошибку в указанном порядке.

Запустите следующую программу, чтобы увидеть вывод функции, которая возвращает string и error:

package main

import (
	"errors"
	"fmt"
	"strings"
)

func capitalize(name string) (string, error) {
	if name == "" {
		return "", errors.New("no name provided")
	}
	return strings.ToTitle(name), nil
}

func main() {
	name, err := capitalize("sammy")
	if err != nil {
		fmt.Println("Could not capitalize:", err)
		return
	}

	fmt.Println("Capitalized name:", name)
}

Output
Capitalized name: SAMMY

Мы определяем capitalize() как функцию, которая принимает строку (имя, которое нужно указать с большой буквы) и возвращает строку и значение ошибки. В main() мы вызываем capitalize() и присваиваем два значения, возвращаемые функцией, для переменных name и err, разделив их запятой с левой стороны оператора :=. После этого мы выполняем нашу проверку if err ! = nil, как показано в предыдущих примерах, используя стандартный вывод и fmt.Println, если ошибка присутствует. Если ошибок нет, мы выводим Capitalized name: SAMMY.

Попробуйте изменить строку "sammy" в name, err := capitalize("sammy")​​​ на пустую строку ("") и получите вместо этого ошибку Could not capitalize: no name provided.

Функция capitalize возвращает ошибку, когда вызов функции предоставляет пустую строку в качестве параметра name. Когда параметр name не является пустой строкой, capitalize() использует strings.ToTitle для замены строчных букв на заглавные для параметра name и возвращает nil для значения ошибки.

Существует несколько конвенций, которым следует этот пример и которые типичны для Go, но не применяются компилятором Go. Когда функция возвращает несколько значений, включая ошибку, конвенция просит, чтобы мы возвращали error последним элементом. При возвращении ошибки функцией с несколькими возвращаемыми значениями, идиоматический код Go также устанавливает для любого значения, не являющегося ошибкой, нулевое значение. Нулевое значение — это, например, пустая строка для string, 0 для целых чисел, пустая структура для структур и nil для интерфейса и типов указателя и т. д. Мы более подробно познакомимся с нулевыми значениями в нашем руководстве по переменным и константам.



91. Обработка ошибок функций с несколькими возвращаемыми значениями:
Когда функция возвращает множество значений, Go требует, чтобы каждое из них было привязано к переменной. В последнем примере мы делали это, указав имена двух значений, возвращаемых функцией capitalize. Эти имена должны быть разделены запятыми и отображаться слева от оператора :=. Первое значение, возвращаемое capitalize, будет присвоено переменной name, а второе значение (error) будет присваиваться переменной err. Бывает, что нас интересует только значение ошибки. Вы можете пропустить любые нежелательные значения, которые возвращает функция, с помощью специального имени переменной _.

В следующей программе мы изменили наш первый пример с функцией capitalize для получения ошибки, передав функции пустую строку (""). Попробуйте запустить эту программу, чтобы увидеть, как мы можем изучить только ошибку, убрав первое возвращаемое значение с переменной _:

package main

import (
	"errors"
	"fmt"
	"strings"
)

func capitalize(name string) (string, error) {
	if name == "" {
		return "", errors.New("no name provided")
	}
	return strings.ToTitle(name), nil
}

func main() {
	_, err := capitalize("")
	if err != nil {
		fmt.Println("Could not capitalize:", err)
		return
	}
	fmt.Println("Success!")
}

Output
Could not capitalize: no name provided

Внутри функции main() на этот раз мы присвоим состоящее из заглавных букв имя (строка, возвращаемая первой) переменной с нижним подчеркиванием (_). В то же самое время мы присваиваем error, которую возвращает capitalize, переменной err. Теперь мы проверим, существует ли ошибка в if err ! = nil. Поскольку мы жестко задали пустую строку как аргумент для capitalize в строке _, err := capitalize(""), это условие всегда будет равно true. В результате мы получим вывод "Could not capitalize: no name provided" при вызове функции fmt.Println в теле условия if. Оператор return после этого будет пропускать fmt.Println("Success!").



92.Оператор panic:
Оператор panic позволяет сгенерировать ошибку и выйти из программы:

package main
import "fmt"
 
func main() {
    fmt.Println(divide(15, 5))
    fmt.Println(divide(4, 0))
    fmt.Println("Program has been finished")
}
func divide(x, y float64) float64{
    if y == 0{ 
        panic("division by zero!")
    }
    return x / y
}

Оператору panic мы можем передать любое сообщение, которое будет выводиться на консоль. Например, в данном случае в функции divide, если второй параметр равен 0, то осуществляется вызов panic("division by zero!").

В функции main в вызове fmt.Println(divide(4, 0)) будет выполняться оператор panic, поскольку второй параметр функции divide равен 0. И в этом случае все последующие операции, которые идут после этого вызова, например, в данном случае это вызов fmt.Println("Program has been finished"), не будут выполняться. В этом случае мы получим следующий консольный вывод:

3
panic: division by zero!

И в конце вывода будет идти диагностическая информация о том, где возникла ошибка.



!!!!93. Оператор defer!!!!

Оператор defer позволяет выполнить определенную операцию после каких-то действий (даже если сработает panic), при этом не важно, где в реальности вызывается эта функция. Например:

package main
import "fmt"
 
func main() {
    defer finish()
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}

Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:

Program has been started
Program is working
Program has been finished

Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:

package main
import  "fmt"
 
func main() {
      
    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}

Консольный вывод:

Program is working
Program has been started
Program has been finished

Дополнение: команда defer помещает вызов функции в стек. Поэтому они выполняются в очередности -LIFO (Last-In, First-Out)

defer запоминает значения переменных, переданных в функцию, на момент объявления defer, а не на момент его вызова. То есть условно:
a:=5

defer myFunc(a) // когда вызовется myFunc - будет передано значение 5, а не 7

a = 7

Оператор defer позволяет выполнить определенную функцию перед выходом из функции

Например. Открыли файл, можно написать defer file.close() и  быть уверенным что файл будет закрыт, даже если до конца функции мы не добрались и возвратили ошибку по каким-то причинам.



94. Оператор defer:
    1) defer в Go используется для отложенного выполнения функции до тех пор, пока окружающая функция не завершится.
    2) defer часто используется для освобождения ресурсов (закрытие файлов, соединений и т. д.) или для выполнения чистки после завершения функции.

Порядок выполнения:

    defer ставит функцию в стек и выполняет ее в обратном порядке после завершения окружающей функции.

    Пример:
    func main() {
        defer fmt.Println("world")
        fmt.Println("hello")
    }

    Вывод:
    hello
    world

В контексте моего предыдущего ответа "окружающая функция" означает функцию, в которой используется ключевое слово defer. Когда мы говорим об "окружающей функции" в контексте defer, мы имеем в виду функцию, внутри которой определены defer операторы. "окружающая функция" в контексте defer - это функция, в которой определены defer операторы, и в которой эти операторы будут выполняться после завершения функции.

    3) Замыкания в defer:
    defer выполняет функцию сразу, но откладывает вызов до завершения окружающей функции, что может привести к изменению значений замкнутых переменных. 

	Пример:

	func main() {
    	x := 1
    	defer func() {
        	fmt.Println(x)
    	}()
	    x = 2
	}

	Вывод:
	2

В контексте программирования на Go, замкнутые переменные относятся к переменным, которые доступны внутри замыканий (closures). Замыкание - это функция, которая ссылается на переменные из внешней области видимости. Когда функция замыкания сохраняет ссылку на переменную из внешней области видимости, эта переменная становится замкнутой.

В моем предыдущем ответе я упомянул пример использования замкнутых переменных в контексте defer. Давайте рассмотрим этот пример:

func main() {
    x := 1
    defer func() {
        fmt.Println(x)
    }()
    x = 2
}

В этом примере переменная x является замкнутой переменной для анонимной функции, которая передается в defer. Когда defer откладывает выполнение этой анонимной функции, она сохраняет ссылку на переменную x. Даже после изменения значения переменной x на 2, функция, отложенная через defer, все равно выводит значение 2, потому что она ссылается на замкнутую переменную x.

Таким образом, замкнутые переменные в Go - это переменные, на которые есть ссылки из внутренних функций (замыканий), и их значения сохраняются внутри замыкания, даже если они изменяются внешней функцией.

Надеюсь, это объяснение помогло вам лучше понять понятие замкнутых переменных в контексте программирования на Go. Если у вас есть дополнительные вопросы, не стесняйтесь задавать.


Когда вызывается функция с ключевым словом defer, она не выполняется немедленно. Вместо этого она добавляется в список функций, которые будут выполняться в обратном порядке после возвращения текущей функции. Это означает, что последняя функция, вызванная с ключевым словом defer, будет выполнена первой после возврата текущей функции.

Ключевое слово defer полезно для обеспечения правильной очистки ресурсов, например, для закрытия файлов или сетевых соединений. Его также можно использовать для упрощения обработки ошибок, позволяя функции возвращать значение ошибки, а затем обрабатывать эту ошибку в одном месте после возврата функции.

Команда defer помещает вызов функции в список. Этот список отложенных вызовов выполняется после того, как объемлющая функция завершит выполнение. Defer обычно используется для упрощения функций, которые занимаются освобождением ресурса.



!!!!95. Отобраения (map) / Карты / Ассоциативыне массивы / Хештаблицы!!!!
Ключи карты могут быть практически любого типа, в отличие от массивов и срезов, где для ключей используется последовательность целых чисел. Для объявления карты с ключами типа string и значениями типа int используется синтаксис:
map[string]int

Хэш таблица в языке go представлена ключевым словом map и может быть объявлена одним из способов ниже (подробнее о них позже):
 m := make(map[key_type]value_type)
 m := new(map[key_type]value_type)
 var m map[key_type]value_type
 m := map[key_type]value_type{key1: val1, key2: val2}

Отображения - структура данных, неупорядоченная коллекция пар "ключ-значение", в которой все ключи различны, а значение, связанное с заданным ключом, можно получить, обновить или удалить независимо от размера карты (отображения).

Отображение в Go представляет собой ссылку на хеш-таблицу, а его тип записывается как map[K]V, где К и V являются типами его ключей и значений.

Все ключи в данном отображении имеют один и тот же тип, как и все значения имеют один и тот же тип, но тип ключей не обязан совпадать с типом значений. Тип ключа К должен быть сравниваемым с помощью оператора ==, чтобы отображение могло проверить, равен ли данный ключ одному из имеющихся в нем.
Создание отображений


Объявление map выглядит так:
var users map[string]int
// string - ключ, int - значения

Но так делать опасно, так мы не инициализировали его и при добавлении значений будут ошибки. (см. ниже)

Поэтому есть 2 более правильных способа создания отображений в Go:

// с помощью встроенной функции make:
m1 := make(map[int]int)

// с помощью использования литерала отображения:
m2 := map[int]int{
    // Пары ключ:значение указываются при необходимости
    12: 2,
    1:  5,
}

fmt.Println(m1) // map[]
fmt.Println(m2) // map[1:5 12:2]

Почему мы не можем просто объявить отображение с помощью ключевого слова var? Объявляя переменную с использованием ключевого слова var, но не присваивая ей явно начальное значение, мы присваиваем ей нулевое значение. Отображение в Go - ссылка на хэш-таблицу, а нулевое значение ссылки nil. Попытавшись в дальнейшем добавить значение для определенного ключа мы получим ошибку "assignment to entry in nil map", которая приведет к панике:

var m map[int]int
m[12] = 3
fmt.Println(m)

// Вывод (сработает паника):
// panic: assignment to entry in nil map

Конечно же мы можем использовать такое объявление когда нам не нужно вручную добавлять элементы, например просто присвоить результату из функции, но нужно быть крайне осторожным в таких случаях.
 
var m map[int]int
m = someFunc()
fmt.Println(m)
// Второй вариант безопаснее
var m = map[int]int{}
m = someFunc()
fmt.Println(m)



Не совсем понятно почему тогда вообще существует такая инициализация: var users map[string]int.

В каких случаях она может понадобиться? Вот в таком:
var ranks map[string]int
ranks = make(map[string]int)
ЕЕ более удобная альтернатива:
ranks = make(map[string]int)



Взгляните, как интересно. Мапа = ссылка. Ссылка = указатель. То есть, объявление мапы под капотом создает указатель на таблицу.

    Отображение в Go представляет собой ссылку на хеш-таблицу

package main

import "fmt"

func main() {
	mm := map[string]int{
		"first":  1,
		"second": 2,
		"third":  3}
	fmt.Println(mm)
	changeMap(mm)
	fmt.Println(mm)
}

func changeMap(mp map[string]int) {
	mp["first"] = 10
}
//Указатели не использовали, и функция ничего не возвращает. Тем не менее, мапа меняется, потому что это ссылка на таблицу.
//Вывод:
//map[first:1 second:2 third:3]
//map[first:10 second:2 third:3]




Создание таблицы в Go.
Допустим, мы хотим посчитать количество вхождений каждого слова в строке, заведем для этого словарь и пройдемся по нему.
package main

func main() {
	var m map[string]int
	for _, word := range []string{"hello", "world", "from", "the",
		"best", "language", "in", "the", "world"} {
		m[word]++
	}
	for k, v := range m {
		println(k, v)
	}
}


Вы гофера подвох видите? — А он есть!
При попытке запуска такой программы получим панику и сообщение «assignment to entry in nil map». А все потому что мапа — ссылочный тип и мало объявить переменную, надо ее проинициализировать:
m := make(map[string]int)

Чуть пониже будет понятно почему это работает именно так. В начале было представлено аж 4 способа создания мапы, два из них мы рассмотрели — это объявление как переменную и создание через make. Еще можно создать с помощью "Composite literals" конструкции
map[key_type]value_type{}
и при желании даже сразу проинициализировать значениями, этот способ тоже валидный. Что касается создания с помощью new — на мой взгляд, оно не имеет смысла, потому что эта функция выделяет память под переменную и возвращает указатель на нее, заполненную zero value типа, что в случае с map будет nil (мы получим тот же результат, что в var, точнее указатель на него).

Основные операции производятся так:
    Вставка:
    m[key] = value

    Удаление:
    delete(m, key)

    Поиск:
    value = m[key] 
    или
    value, ok = m[key] 




Обход таблицы в go
Рассмотрим следующую программу:
package main

import "fmt"

func main() {
	m := map[int]bool{}
	for i := 0; i < 5; i++ {
		m[i] = ((i % 2) == 0)
	}
	for k, v := range m {
		fmt.Printf("key: %d, value: %t\n", k, v)
	}
}


Запуск 1:
key: 3, value: false
key: 4, value: true
key: 0, value: true
key: 1, value: false
key: 2, value: true


Запуск 2:
key: 4, value: true
key: 0, value: true
key: 1, value: false
key: 2, value: true
key: 3, value: false

Как видим, вывод разнится от запуска к запуску. А все потому, что мапа в Go unordered, то есть не упорядоченная. Это значит, что полагаться на порядок при обходе не надо.


Для поиска значений по ключу, присваивания поверх существующих значений или добавления значений в карту используются квадратные скобки [].
temperature := map[string]int{
    "Земля": 15, // Пары ключ-значения являются композитными литералами для карт
    "Марс":  -65,
}

temp := temperature["Земля"]
fmt.Printf("Средняя температура на поверхности Земли составляет %v° C.\n", temp) // Выводит: Средняя температура на поверхности Земли составляет 15° C. 

temperature["Земля"] = 16 // Небольшое изменение климата
temperature["Венера"] = 464

fmt.Println(temperature) // Выводит: map[Венера:464 Земля:16 Марс:-65]



При попытке получить доступ к ключу, которого нет в карте, результатом будет нулевое значение типа (int):
moon := temperature["Луна"]
fmt.Println(moon) // Выводит: 0

В Go используется синтаксис comma, ok, что нужен для обозначения разницы между ключом "Луна", которого нет в карте, и тем, у чего значение 0 в отображении:
if moon, ok := temperature["Луна"]; ok { // Синтаксис comma, ok
     fmt.Printf("Средняя температура на поверхности Луны составляет %v° C.\n", moon)
} else {
    fmt.Println("Где Луна?") // Выводит: Где Луна?
}
Переменная moon должна содержать значение ключа "Луна" или же нулевое значение. При наличии ключа значение дополнительной переменной ok будет равно true,  в противном случае — false.



Копируются ли карты в Golang?
Ранее мы упоминали, что массивы копируются во время присваивания к новым переменным или передачи к функциям или методам. То же самое верное в отношении примитивных типов вроде int или float64.

Карты устроены иначе. В следующем примере planets и planetsMarkII делят одну и ту же базовую информацию. Как видите, изменения в одном, затрагивают и другой. Это не всегда кстати.
planets := map[string]string{
    "Земля": "Сектор ZZ9",
    "Марс":  "Сектор ZZ9",
}

planetsMarkII := planets
planets["Земля"] = "упс"

fmt.Println(planets) // Выводит: map[Земля:упс Марс:Сектор ZZ9]
fmt.Println(planetsMarkII) // Выводит: map[Земля:упс Марс:Сектор ZZ9]

delete(planets, "Земля") // Земля удаляется из карты
fmt.Println(planetsMarkII) // Выводит: map[Марс:Сектор ZZ9]
Когда встроенная функция delete удаляет элемент из карты, как planets, так и planetsMarkII изменяются. При передачи карты функции или методу содержимое карты может измениться. Такое поведение напоминает несколько срезов, что указывают на один и тот же базовый массив.

Проделаем похожий трюк с мапой:
package main

func foo(m map[int]int) { 
    m[10] = 10 
}

func main() {
	m := make(map[int]int)
	m[10] = 15
	println("m[10] before foo =", m[10])
	foo(m)
	println("m[10] after foo =", m[10])
}


И о чудо:
m[10] before foo = 15
m[10] after foo = 10

Значение поменялось. «Что же, мапа передается по ссылке?», — спросите вы. Нет. В Go не бывает ссылок. Невозможно создать 2 переменные с 1 адресом, как в С++ например. Но зато можно создать 2 переменные, указывающие на один адрес (но это уже указатели, и они в Go есть).

Пусть у нас есть функция fn, которая инициализирует мапу m. В основной функции мы просто объявляем переменную, отправляем на инициализацию и смотрим что получилось после.

package main

import "fmt"

func fn(m map[int]int) {
	m = make(map[int]int)
	fmt.Println("m == nil in fn?:", m == nil)
}

func main() {
	var m map[int]int
	fn(m)
	fmt.Println("m == nil in main?:", m == nil)
}

Вывод:
m == nil in fn?: false
m == nil in main?: true

Итак, переменная m передалась по значению, поэтому, как в случае с передачей в функцию обычного int, не поменялась (поменялась локальная копия значения в fn). Тогда почему же меняется значение, лежащее в самой m? Мапа в Go — это просто указатель на структуру hmap. Это и является ответом на вопрос, почему при том, что мапа передается в функцию по значению, сами значения, лежащие в ней меняются — все дело в указателе. Так же структура hmap содержит в себе следующее: количество элементов, количество «ведер» (представлено в виде логарифма для ускорения вычислений), seed для рандомизации хэшей (чтобы было сложнее заddosить — попытаться подобрать ключи так, что будут сплошные коллизии), всякие служебные поля и главное указатель на buckets, где хранятся значения.



Предварительное обозначение карты через make
Некоторые аспекты карт напоминают срезы. Только если вы не инициализировали их через композитный литерал, карты нужно обозначить через встроенную функцию make.

Для карт make принимает один или два параметра. Второй предварительно обозначает место для количества ключей, что напоминает вместимость срезов. При использовании make начальная длина карты всегда будет нулевой:
temperature := make(map[float64]int, 8)



Использование карты для подсчета частоты использования элементов
В Листинге 3 определяется частота упоминания температур, значения взяты из MAAS API. Если бы frequency была срезом, ключи были бы целыми числами, а базовому массиву потребовалось бы зарезервировать место для подсчета температур, что в действительности не был произведен. Для таких случаев карта намного удобнее.
temperatures := []float64{
    -28.0, 32.0, -31.0, -29.0, -23.0, -29.0, -28.0, -33.0,
}

frequency := make(map[float64]int)

for _, t := range temperatures { // Итерирует через срез (индекс, значение)
     frequency[t]++
}

for t, num := range frequency { // Итерирует через карту (ключ, значение)
     fmt.Printf("%+.2f встречается %d раз(а) \n", t, num)
}
Итерация через ключевое слово range работает одинаково со срезами, массивам и картами. Вместо индекса и значения, для итерации карты используется ключ и значение. Обратите внимание, что Go не гарантирует порядок ключей карты, поэтому выводы при различных запусках могут отличаться.



Группирование данных с картами и срезами Golang
Вместо определения частоты упоминания температур сгруппируем их вместе с разделением каждой в 10°. Для этого в следующем пример карты группируются в срез температур данной группы.
temperatures := []float64{
    -28.0, 32.0, -31.0, -29.0, -23.0, -29.0, -28.0, -33.0,
}

groups := make(map[float64][]float64) // Карта с ключами float64 и значениями []float64 

for _, t := range temperatures {
    g := math.Trunc(t/10) * 10 // Округляет температуры вниз -20, -30 и так далее
    groups[g] = append(groups[g], t)
}

for g, temperatures := range groups {
    fmt.Printf("%v: %v\n", g, temperatures)
}

Результат программы:
30: [32]
-30: [-31 -33]
-20: [-28 -29 -23 -29 -28]



Множества в Golang
Множество является коллекцией, похожей на массив. Отличие в том, что каждый элемент должен повторяться только один раз. В Go коллекций множеств, но вы всегда можете сымпровизировать, используя карту, как показано в следующем примере. Значение не важно, но true удобно для проверки того, является ли элемент частью множества. Если температура находится в карте, ее значение true, это часть множества.
var temperatures = []float64{
    -28.0, 32.0, -31.0, -29.0, -23.0, -29.0, -28.0, -33.0,
}

set := make(map[float64]bool) // Создание карты с булевыми значениями
for _, t := range temperatures {
    set[t] = true
}

if set[-28.0] {
    fmt.Println("часть множества") // Выводит: часть множества
}

fmt.Println(set) // Выводит: Prints map[-31:true -29:true -23:true -33:true -28:true 32:true]

Видно, что карта содержит по одному ключу для каждой температуры, дубликаты удаляются. У ключей карты произвольный порядок, поэтому перед их сортировкой температуры нужно конвертировать обратно в срез:
unique := make([]float64, 0, len(set))
for t := range set {
    unique = append(unique, t)
}
sort.Float64s(unique)

fmt.Println(unique) // Выводит: [-33 -31 -29 -28 -23 32]

!!!!96. Приведение типов!!!!

Приведение целочисленных типов
Выбор одного или другого типа в основном зависит от производительности, однако в некоторых случаях вам придется преобразовать один целочисленный тип в другой. Например, Go иногда автоматически генерирует числовые значения как int, а это может не соответствовать вашему входному значению. Если вы введете значение int32, вы не сможете использовать числа int и int32 в одном и том же математическом выражении, пока не преобразуете их типы данных соответствующим образом.

И так, преобразования между целыми числами делают очень просто. Вам нужно обернуть в скобки переменную которую вы хотите конвертировать и слева от скобок написать нужный тип, например:
Преобразование int8 в int32 делается таким образом:

var index int8 = 15
var bigIndex int32
bigIndex = int32(index)

// Выведем:
fmt.Println(bigIndex)         // 15
fmt.Printf("%T \n", bigIndex) // int32

// По аналогии выше легко понять как конвертировать в другие типы:
var a int32 = 22
var b uint64
b = uint64(a)

// Выведем
fmt.Println(b)         // 22
fmt.Printf("%T \n", b) // uint64

Примечание: %T - параметр функции Printf, позволяющий вывести тип переменной. 

Важно: Go позволяет преобразовывать типы с большим количеством бит в типы с меньшим количеством бит. 

Сделать это можно вот так:

var big int64 = 64

var little int8

little = int8(big)

fmt.Println(little) //64

Однако, при преобразовании целых чисел, может быть превышено максимальное значение для данного типа данных, и выполнится перенос (потеря данных):

var big int64 = 129
var little = int8(big)
fmt.Println(little)  //-127

Для того чтобы узнать какое максимальное значение мы можем положить в определенный тип воспользуемся константами из пакета math:

fmt.Println(math.MaxInt8)   // 127
fmt.Println(math.MaxUint8)  // 255
fmt.Println(math.MaxInt16)  // 32767
fmt.Println(math.MaxUint16) // 65535
// ...



Приведение целых чисел и чисел с плавающей точкой

Преобразование целого числа в число с плавающей точкой ничем не отличается от преобразования целого числа. Можно использовать встроенную конверсию, обернув float64()​​​ или float32() вокруг целого числа:  

var x int64 = 57
var y float64 = float64(x)
fmt.Print(y) // 57

Преобразование чисел с плавающей точкой в целые числа 

Go может преобразовывать float в int. Но делает это с потерей точности. Синтаксис преобразования не меняется.

var f float64 = 56.231
var i int = int(f)
fmt.Println(f) // 56.231
fmt.Println(i) // 56

Числа, конвертируемые с помощью деления 

a := 5 / 2
fmt.Println(a) // 2

Если при делении используются числовые типы с плавающей точкой, тогда все остальные типы будут автоматически объявляться как числа с плавающей точкой:
 

a := 5.0 / 2
fmt.Println(a) //2.5



 Конвертация строк в байты/rune и обратно

Строка в Go это срез байтов, поэтому мы можем конвертировать байты в строку и наоборот:

package main

import (
    "fmt"
)

func main() {
    a := "str"

    b := []byte(a)

    c := string(b)

    fmt.Println(a) // str

    fmt.Println(b) // [115 116 114] - побайтовый срез

    fmt.Println(c) // str
}

Первая строка вывода - значение переменной "a", вторая - ее побайтовый срез, третья - значение переменной "c", являющейся  результатом конвертации байтов в строку.

Тоже самое работает и со срезами типа rune:

package main

import (
    "fmt"
)

func main() {
    a := "строка"

    b := []rune(a) // срез рун

    c := string(b)

    fmt.Println(a) // строка

    fmt.Println(b) // [1089 1090 1088 1086 1082 1072] - срез рун

    fmt.Println(c) // строка
}



Конвертация в строки

Для начала рассмотрим конвертацию целых чисел в строки. Golang - язык со статической и строгой типизацией. Он не позволит вам сложить строку и число. Например напишем такой код:

package main

import (
    "fmt"
)

func main() {
    user := "ученик"
    steps := 4

    fmt.Println("Поздравляю, " + user + "! Ты прошел " + steps + " шага по приведению типов.")
}

Мы получим ошибку во время компиляции:

invalid operation: ("Поздравляю, " + user + "! Ты прошел ") + steps (mismatched types string and int)

При конвертации чисел в строки очень удобно использовать пакет strconv, он обладает методом Itoa, превращающим числовое значение (int) переменной в строковое (string).

В теории звучит очень сложно, на деле - просто. Рассмотрим на примере.

package main

import (
	"fmt"
	"strconv"
)

func main() {
	a := strconv.Itoa(2020) // int -> string
	fmt.Printf("%T \n", a) // тип - string
	fmt.Println(a) // 2020
}

А теперь вернемся к примеру выше. Чтобы исправить прошлую ошибку - надо привести steps к строке.  

package main

import (
	"fmt"
	"strconv"
)

func main() {
	user := "ученик"
	steps := 4

	fmt.Println("Поздравляю, " + user + "! Ты прошел " + strconv.Itoa(steps) + " шага по приведению типов.")
}

Да, в этом примере не обязательно использовать strconv, мы могли бы просто перечислить в Print все переменные как аргументы функции, но могут возникнуть ситуации где никак не обойтись без конвертации. Мы лишь показали как это делать.

Интересное дополнение, метод Itoa это всего-лишь обертка для FormatInt: (кусок исходного кода пакета strconv)

// Itoa is equivalent to FormatInt(int64(i), 10).
func Itoa(i int) string {
	return FormatInt(int64(i), 10)
}

То-есть вызывая метод Itoa мы по сути вызываем FormatInt который принимает систему счисления в качестве 2 аргумента, но туда сразу передается - десятичная система счисления.

Но никто нам не мешает напрямую вызыватьFormatInt, полезно если работаем с разными системами счисления:

package main

import (
	"fmt"
	"strconv"
)

func main() {
	// приставка '0x' означает что число в шестнадцатеричной системе счисления
	var a int64 = 0xB // 'B' в шестнадцатеричной это 11 в десятичной системе
	fmt.Println(strconv.FormatInt(a, 10)) // 11
	fmt.Println(strconv.FormatInt(a, 16)) // b
}

Конвертация целых беззнаковых чисел в строку


По аналогии с FormatInt есть такой метод как FormatUint, пример:

var a uint64 = 10101
res := strconv.FormatUint(a, 10)
fmt.Println(res) // 10101


Конвертация чисел с плавающей запятой в строку 

Для этого есть функция FormatFloat:

package main

import (
	"fmt"
	"strconv"
)

func main() {
	var a float64 = 1.0123456789

	// 1 параметр - число для конвертации
	// fmt - форматирование
	// prec - точность (кол-во знаков после запятой)
	// bitSize - 32 или 64 (32 для float32, 64 для float64)
	fmt.Println(strconv.FormatFloat(a, 'f', 2, 64)) // 1.01

	// если мы хотим учесть все цифры после запятой, то можем в prec передать -1
	fmt.Println(strconv.FormatFloat(a, 'f', -1, 64)) // 1.0123456789

	// Возможные форматы fmt:
	// 'f' (-ddd.dddd, no exponent),
	// 'b' (-ddddp±ddd, a binary exponent),
	// 'e' (-d.dddde±dd, a decimal exponent),
	// 'E' (-d.ddddE±dd, a decimal exponent),
	// 'g' ('e' for large exponents, 'f' otherwise),
	// 'G' ('E' for large exponents, 'f' otherwise),
	// 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or
	// 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).
	var b float64 = 2222 * 1023 * 245 * 2 * 52
	fmt.Println(strconv.FormatFloat(b, 'e', -1, 64)) // 5.791874088e+10
}

 Так же можно использовать пакет "fmt". Он обладает удобным методом Sprintf. Вот шпаргалка по всему пакету.

package main

import (
    "fmt"
)

func main() {
    fmt.Println(fmt.Sprint(20.19)) // Краткая форма

    a := 20.20
    fmt.Println(fmt.Sprintf("%f", a)) // Полная форма
}

Внимание! Использовать fmt для конвертации нежелательно из-за того что производительность ниже по сравнению с strconv.
Конвертация bool в string

Тут все просто:

var a = true
res := strconv.FormatBool(a)
fmt.Println(res)     	// true
fmt.Printf("%T", res)   // string


Конвертация строк в другие типы

Рассмотрим для начала конвертацию строк в целые числа на примерах:

package main

import (
    "fmt"
)

func main() {
    foo := "10"
    bar := "15"
    baz := foo - bar
    fmt.Println(baz)
}

Если вы попробуете запустить этот код, то вы столкнетесь с ошибкой:

  
invalid operation: foo - bar (operator - not defined on string)

  

Встретите вы её, так как операнд вычитания не является действительным для строк. Это можно исправить, использовав метод пакета strconv - Atoi:

package main

import (
	"fmt"
	"strconv"
)

func main() {
	foo := "10"
	bar := "15"
	barInt, err := strconv.Atoi(bar)
	if err != nil {
		panic(err)
	}
	fooInt, err := strconv.Atoi(foo)
	if err != nil {
		panic(err)
	}
	baz := barInt - fooInt
	fmt.Println(baz) //5
}

Важно: при конвертации строки, которая не содержит в себе число - ваша программа выдаст вам ошибку 

strconv.Atoi: parsing "not a number": invalid syntax

Так как метод Atoi кроме результата возвращает еще и ошибку, то мы можем легко это проверить (вспоминаем урок 2 модуля про ошибки):
 

package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "323str"
	result, err := strconv.Atoi(s)
	if err != nil {
		fmt.Println(err) // strconv.Atoi: parsing "323str": invalid syntax
	} else {
		fmt.Println(result)
	}
}

Конвертация string в float с помощью метода ParseFloat:

package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "23.23456"
	// как и в прошлом шаге, здесь 2 параметр - bitSize
	// bitSize - 32 или 64 (32 для float32, 64 для float64)
	// но нужно понимать что метод все равно вернет float64
	result, err := strconv.ParseFloat(s, 64)
	if err != nil {
		panic(err)
	}
	fmt.Println(result)        			 // 23.23456
	fmt.Printf("%T \n", result)  // float64

	// Конкретный пример для разных bitSize:
	s = "1.0000000012345678"
	//  не будем обрабатывать ошибки в примерах, но на практике так не делайте ;)
	result32, _ := strconv.ParseFloat(s, 32)
	result64, _ := strconv.ParseFloat(s, 64)
	fmt.Println("bitSize32:", result32)  // вывод 1 (не уместились)
	fmt.Println("bitSize64:", result64)  // вывод  1.0000000012345678
}

Полезно знать!
Так же по аналогии с примерами выше есть методы ParseUint, ParseInt, ParseBool.

Кстати, метод Atoi эквивалентен ParseInt(s, 10, 0), конвертированному в int.
Примеры:

package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "-12345"
	res, err := strconv.ParseInt(s, 10, 64)
	if err != nil { // не забываем проверить ошибку
		panic(err)
	}

	fmt.Println(res) // -12345

	s = "12345"
	res2, err := strconv.ParseUint(s, 10, 64)
	if err != nil {  // не забываем проверить ошибку
		panic(err)
	}
	fmt.Println(res2) // 12345
}

 
Конвертация string в bool

s := "true"
res, err := strconv.ParseBool(s)
if err != nil { // не забываем проверить ошибку
	panic(err)
}
fmt.Println(res)      // true
fmt.Printf("%T", res)  // bool



!!!!97. Интерфейсы!!!!
https://metanit.com/go/tutorial/6.1.php
https://golangify.com/interface
https://www.digitalocean.com/community/tutorials/defining-methods-in-go-ru

!!!!98. Пакеты, моудли и go. mod!!!!

Модули и Пакеты
    Пакеты: Пакет в Go - это коллекция файлов Go в одной директории с общим путем импорта. Они используются для организации кода и обеспечивают пространство имен в Go. Пакеты могут импортироваться в другие пакеты для использования их функций, типов и переменных.

    Модули: Модуль в Go - это коллекция связанных пакетов, хранящихся вместе с файлом go.mod. Модули являются новым способом организации и версионирования кода в Go с версии 1.11. Они позволяют управлять зависимостями проекта и обеспечивают изолированную среду разработки.
	
	Файл go.mod - это основной файл модуля в Go. Он используется для определения имени модуля и его зависимостей. Когда создается новый модуль или добавляются новые зависимости, они записываются в файл go.mod.

	Когда вы импортируете внешние зависимости в свой проект, go.mod автоматически обновляется с информацией о зависимостях. Например, если вы хотите использовать библиотеку github.com/gorilla/mux, вы можете добавить ее в свой проект следующим образом:
sh:
go get github.com/gorilla/mux
После этого ваш go.mod будет выглядеть примерно так:

99. Процесс создагия go.mod файла
Понимание создания файла go.mod связано с тем, что в языке Go используется концепция модулей, а не просто отдельных проектов или программ. Поэтому создание файла go.mod связано с определением модуля, в котором содержится ваш код.
Создание файла go.mod

    Переход в директорию с кодом: Первым шагом является переход в директорию, в которой находится код вашего проекта. Важно понимать, что модуль в Go связан с директорией, а не с отдельным файлом или программой.

    Определение имени модуля: Когда вы находитесь в директории с вашим кодом, вы можете выполнить команду go mod init <имя_модуля>. Это команда инициализации модуля в Go и создания файла go.mod.

    Влияние наименования программы: Наименование программы не имеет никакого прямого влияния на создание файла go.mod. Однако, имя модуля (которое вы указываете при создании файла go.mod) может быть основано на имени вашей программы или проекта, чтобы лучше описать контекст вашего модуля.

Примеры создания файла go.mod

Предположим, у вас есть следующая структура проекта:
myproject/
├─── main.go
└─── util/
     └─── utils.go

    Пример 1: Создание файла go.mod в корневой директории проекта:
sh
cd /path/to/myproject
go mod init example.com/myproject
В этом примере мы переходим в директорию /path/to/myproject, где находится наш код. Затем мы инициализируем модуль с именем example.com/myproject, используя команду go mod init.


    Пример 2: Создание файла go.mod в директории с файлом main.go:
Если ваш файл main.go находится в поддиректории вашего проекта, вы также можете создать go.mod в этой поддиректории:

sh
cd /path/to/myproject
cd util  # Переходим в директорию с файлом main.go
go mod init example.com/myproject/util

В этом случае мы переходим сначала в корневую директорию проекта, а затем в директорию util, где находится файл main.go. После этого мы инициализируем модуль с именем example.com/myproject/util.

    Пример 3: Использование имени программы для модуля:
Если вы хотите использовать имя вашей программы в качестве имени модуля, вы можете сделать это. Например, если ваш файл main.go выглядит так:

go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}


Вы можете создать файл go.mod следующим образом:
sh
cd /path/to/myproject
go mod init example.com/myproject

В этом случае мы инициализируем модуль с именем example.com/myproject, что соответствует имени вашего проекта.

100. Как связаны main.go и go.mod:
Файл main.go и go.mod связаны через модуль в языке Go. Однако, они имеют разные функции:

    main.go: Это файл, содержащий ваш код на Go, который обычно является точкой входа (entry point) для вашего приложения. В файле main.go обычно определена функция main, которая является стартовой точкой выполнения вашего приложения.

    go.mod: Это файл, который определяет модуль вашего проекта, включая его зависимости. Файл go.mod используется для управления зависимостями проекта и определения имени модуля.

Файл main.go может находиться внутри модуля Go, но не обязательно. Однако создание файла go.mod происходит на уровне модуля, а не на уровне отдельного файла. Это означает, что файл go.mod создается для всего модуля, а не для отдельных файлов внутри него.

Как уже упоминалось в предыдущем ответе, go.mod создается путем выполнения команды go mod init <имя_модуля>. Это делается в директории, которая будет представлять ваш модуль. Файл go.mod определяет модуль и все его зависимости, независимо от того, содержится ли в этом модуле файл main.go или нет.

Таким образом, ответ на ваш вопрос: нет, нельзя создать go.mod только для файла, не являющегося main файлом. Файл go.mod создается для всего модуля в целом, который может содержать несколько файлов, в том числе и файл main.go, если это требуется.

101.Зачем создают go.mod файл даже в тех проектах, в которых нет импорта внешних зависимостей?

Создание файла go.mod даже в проектах без импорта внешних зависимостей имеет несколько причин:

    Явное определение модуля: Файл go.mod служит явным признаком, что ваш проект является модулем Go. Он определяет модуль и его имя, что упрощает понимание идентификации проекта.

    Управление версиями и зависимостями: Даже если в вашем проекте нет внешних зависимостей на данный момент, создание файла go.mod позволяет в будущем добавлять и управлять зависимостями. Вы можете добавить внешние зависимости по мере необходимости, а файл go.mod обеспечит удобное место для их определения и управления версиями.

    Воспроизводимость сборки: Использование модулей и файла go.mod обеспечивает воспроизводимость сборки проекта. Даже если ваш проект в настоящее время не зависит от внешних библиотек, создание модуля помогает зафиксировать состояние вашего проекта и его зависимостей на момент создания файла go.mod, что позволяет легко воспроизвести среду разработки на других компьютерах.

    Облегчение совместной работы: Файл go.mod обеспечивает явную документацию о зависимостях и версиях, которые использует ваш проект. Это упрощает совместную работу и сопровождение проекта другими разработчиками.

    Использование инструментов и сервисов: Некоторые инструменты и сервисы, такие как некоторые CI/CD системы и системы управления зависимостями, могут требовать наличие файла go.mod в корне проекта. Создание файла go.mod обеспечивает совместимость с такими инструментами и сервисами.

102. Внутреннее устройство файла go.mod.
Файл go.mod является текстовым файлом, который используется для определения модуля Go и его зависимостей. Он имеет простую структуру и содержит несколько основных элементов:

Заголовок модуля: В самом верху файла go.mod располагается заголовок, который определяет имя вашего модуля. Это обычно выглядит как module example.com/mymodule, где example.com/mymodule - это имя вашего модуля. Пример:
module example.com/mymodule

Зависимости: Зависимости вашего модуля указываются в секции require. Каждая зависимость имеет формат имя_зависимости версия_зависимости. Пример:
require (
    github.com/gorilla/mux v1.8.0
    golang.org/x/net v0.0.0-20220119191946-12138167d1cf
)

Замены (replaces): Этот блок может содержать замены для зависимостей. Замены могут использоваться для подмены импортированных пакетов. Например:
replace (
    example.com/foo => /path/to/foo
    github.com/some/dependency => github.com/some/forked-dependency v1.2.3
)

Игнорируемые модули (exclude): Этот блок позволяет игнорировать определенные версии зависимостей. Например:
    exclude (
        github.com/some/dependency v1.2.3
    )

Пример полного файла go.mod:
module example.com/mymodule

require (
    github.com/gorilla/mux v1.8.0
    golang.org/x/net v0.0.0-20220119191946-12138167d1cf
)

replace (
    example.com/foo => /path/to/foo
    github.com/some/dependency => github.com/some/forked-dependency v1.2.3
)

exclude (
    github.com/some/dependency v1.2.3
)


!!!!103. Нулевые значения!!!!

Все встроенные типы имеют нулевые значения. Любую выделенную переменную можно использовать, даже если ей никогда не назначалось значение. Мы видим нулевые значения следующих типов:

package main

import "fmt"

func main() {
	var a int
	var b string
	var c float64
	var d bool

	fmt.Printf("var a %T = %+v\n", a, a)
	fmt.Printf("var b %T = %q\n", b, b)
	fmt.Printf("var c %T = %+v\n", c, c)
	fmt.Printf("var d %T = %+v\n\n", d, d)
}

Output
var a int =  0
var b string = ""
var c float64 = 0
var d bool = false

Мы использовали оператор %T в выражении fmt.Printf. Он предписывает функции вывести тип данных для переменной.

Поскольку в Go все значения имеют нулевое значение, у нас не может быть неопределенных значений, как в некоторых других языках. Например, в некоторых языках булево выражение может иметь значение undefined, true или false, то есть переменная может иметь три состояния. В Go булево выражение не может иметь более двух состояний.

!!!!104. Проверка на пустоту!!!!
В языке программирования Go проверка объекта на пустоту зависит от его типа. Вот несколько способов проверки пустоты для различных типов данных:

    Строки: Для проверки строки на пустоту используйте функцию len(), чтобы узнать длину строки, и проверьте, равна ли она нулю. Например:
str := "hello"

if len(str) == 0 {
    fmt.Println("Строка пуста")
} else {
    fmt.Println("Строка не пуста")
}

    Срезы: Для проверки среза на пустоту также используйте функцию len(). Например:
slice := []int{1, 2, 3}

if len(slice) == 0 {
    fmt.Println("Срез пуст")
} else {
    fmt.Println("Срез не пуст")
}

    Карты (map): Для карты используйте функцию len() для проверки количества элементов в ней. Например:
m := map[string]int{"a": 1, "b": 2}

if len(m) == 0 {
    fmt.Println("Карта пуста")
} else {
    fmt.Println("Карта не пуста")
}

    Интерфейсы (interfaces): Для проверки интерфейса на пустоту используйте оператор сравнения с nil. Например:
var i interface{}

if i == nil {
    fmt.Println("Интерфейс пуст")
} else {
    fmt.Println("Интерфейс не пуст")
}

    Другие типы: Для других типов данных проверка на пустоту может быть специфичной. Например, для чисел вы можете проверить их равенство нулю.

    Указатели: Для указателей проверка на равенство nil будет означать, что указатель не ссылается на какой-либо объект.
var ptr *int

if ptr == nil {
    fmt.Println("Указатель пуст")
} else {
    fmt.Println("Указатель не пуст")
}

Обратите внимание, что для некоторых типов данных Go предоставляет встроенные функции для проверки на пустоту, например, для срезов, карт и каналов. Однако, описанные выше методы применимы для большинства типов данных в Go.

    Функции: Для функций невозможно явно проверить их на пустоту. Однако, вы можете проверить, была ли функция определена или задана нулевой (nil) функцией.
var fn func()

if fn == nil {
    fmt.Println("Функция не определена")
} else {
    fmt.Println("Функция определена")
}

    Структуры: Для проверки структуры на пустоту лучше всего проверить нулевое значение структуры или поля, которые должны быть нулевыми, если структура считается пустой.
type Person struct {
    Name string
    Age  int
}

var p Person

if p == (Person{}) {
    fmt.Println("Структура пуста")
} else {
    fmt.Println("Структура не пуста")
}

    Пустые значения для типов: Некоторые типы данных в Go имеют свои собственные пустые значения, которые могут быть использованы для проверки на пустоту. Например, для строк это "", для чисел это 0, для указателей это nil и т.д.
var str string

if str == "" {
    fmt.Println("Строка пуста")
} else {
    fmt.Println("Строка не пуста")
}


Еще несколько распространенных способов:
1) Создание пустой переменной и сравнение проверяемых на пустату переменных с ней.
2) Проверка через err



!!!!!105. nill!!!!
В языке программирования Go ключевое слово nil используется для представления нулевого значения для указателей, интерфейсов, функций, карт (map), срезов (slice) и каналов (channel). Фактически, nil представляет собой нулевое значение для любого типа ссылочной (reference) природы в Go.

Функция nil используется для следующих целей:

    Указатели (pointers): Переменная типа указатель, которая не ссылается ни на какое значение, имеет значение nil. Это означает, что она не указывает на какой-либо адрес в памяти.

var ptr *int
fmt.Println(ptr) // Выведет "nil"

    Интерфейсы (interfaces): Пустой интерфейс (interface{}) может содержать значение nil, что означает, что он не ссылается ни на какой конкретный тип.

var i interface{}
fmt.Println(i) // Выведет "nil"

    Функции (functions): Переменная функционального типа, которая не указывает на никакую функцию, имеет значение nil. Такое значение можно использовать для проверки наличия или отсутствия функции.

var fn func()
fmt.Println(fn) // Выведет "nil"

    Карты (maps), срезы (slices) и каналы (channels): Карта, срез или канал со значением nil не указывают на какую-либо структуру данных или поток данных.

var m map[string]int
fmt.Println(m) // Выведет "nil"

var s []int
fmt.Println(s) // Выведет "nil"

var ch chan int
fmt.Println(ch) // Выведет "nil"

Использование nil позволяет программисту явно указывать отсутствие значения для указателей, интерфейсов, функций и других ссылочных типов данных. Это может быть полезно, например, для проверки наличия данных перед их использованием или для обозначения отсутствия действий или реализаций.

106.

107.

108.

109.

110.



  