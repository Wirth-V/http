//Позиционные аргументы
/*
Обычно команда принимает ряд аргументов, которые определяют предмет ее внимания.
 Например, команда head, которая выводит
 первые строки файла, часто вызывается как head example.txt. Файл example.txt
 является позиционным аргументом в вызове данной команды.

Функция Parse() будет продолжать анализировать все найденные флаги до тех пор,
пока не обнаружит нефлаговый аргумент. Пакет flag использует для этого функции
Args() и Arg().
*/

/*Давайте для примера соберем упрощенную реализацию команды head, которая
отображает несколько начальных строк заданного файла.*/

// Команда запуска через комндную строку: go run head.go -- head.go
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
)

func main() {
	//определяем переменную count для хранения количества строк, которые
	//программа должна вывести из файла
	var count int
	flag.IntVar(&count, "n", 5, "number of lines to read from the file")
	flag.Parse()
	//Сначала мы определяем переменную io.Reader, которая будет установлена либо
	// ​​в файл, запрошенный пользователем, либо в стандартный ввод, переданный программе
	var in io.Reader
	//В операторе if мы используем функцию flag.Arg для доступа к первому
	//позиционному аргументу, который идет после всех флагов.
	//Если пользователь указал имя файла, оно будет установлено. В противном
	//случае это будет пустая строка ("").
	if filename := flag.Arg(0); filename != "" {
		//Когда имя файла указано, мы используем функцию os.Open, чтобы открыть
		//этот файл и установить для него переменную io.Reader, которую определили ранее
		f, err := os.Open(filename)
		if err != nil {
			fmt.Println("error opening file: err:", err)
			os.Exit(1)
		}
		defer f.Close()
		in = f
	} else {
		//В cлучае когда мы не передаем файл, мы используем os.Stdin для чтения
		//из стандартного ввода.
		in = os.Stdin
	}
	//В последнем разделе используется *bufio.Scanner
	//(созданный с помощью bufio.NewScanner) для чтения строк из переменной
	//io.Reader. Мы выполняем итерацию до значения count с помощью цикла for,
	//вызывая break, если при сканировании строки с помощью buf.Scan получается
	//значение false – это значит, что количество строк меньше числа, запрошенного пользователем
	buf := bufio.NewScanner(in)
	for i := 0; i < count; i++ {
		if !buf.Scan() {
			break
		}
		fmt.Println(buf.Text())
	}
	if err := buf.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error reading: err:", err)
	}
}

/*
Запустите эту программу и выведите на экран содержимое файла, который вы только
что написали, используя head.go в качестве аргумента файла:

go run head.go -- head.go

Разделитель — является специальным флагом, который значит для пакета flag, что
далее флаговых аргументов нет. Вы получите такой вывод:

package main
import (
"bufio"
"flag"

Используйте флаг -n, который вы определили ранее, чтобы откорректировать объем вывода:

go run head.go -n 1 head.go

Это выведет только оператор package:

package main

Наконец, когда программа обнаруживает, что позиционные аргументы не были
предоставлены, она считывает ввод со стандартного ввода, как head. Попробуйте
запустить эту команду:

echo "fish\nlobsters\nsharks\nminnows" | go run head.go -n 3

Вы получите такой вывод:

fish
lobsters
sharks

Поведение функций flag до сих пор ограничивалось вызовом команды.
Такое поведение не всегда необходимо (особенно если вы пишете инструмент
командной строки, который поддерживает подкоманды).
*/
